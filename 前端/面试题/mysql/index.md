# mysql 
## mysql对索引的定义： 索引（index)是帮助mysql高效获取数据的数据结构。
索引的本质是一种数据结构；索引不可能全部存储在内存中，往往以索引文件的形式存储在磁盘上；
提高数据检索和排序的效率，cpu\io成本
劣势：虽然提高了查询速度，但对表的insert、update、delete不仅更新数据还更新索引列字段；
索引也是一张表，指向实体表记录，占用空间；

哪些情况需要创建索引：
主键自动建立唯一索引；
频繁查询的字段；
外键关系建立索引；
组合索引；
排序字段创建索引；
统计分组字段创建索引；（分组比order更慢，group by 包含order by）

不需要创建索引：
表记录太少
经常增删改的表或者字段
where条件里用不到的字段不创建索引；
过滤性不好的字段（非唯一性字段不创建索引；
索引的结构：

索引的分类：


## 索引的文件存储形式与引擎有关：
mysql中的存储引擎：myisam，innodb，memory
memory用的是hash索引
myisam，innodb 用的是b+tree索引
大部分说的存储引擎都是innodb。
在mysql中输入 “show index from 表名” 就可以查看引擎
数据都是放在磁盘中，读数据的时候是从磁盘读到内存当中的。
磁盘的读写速度比内存小很多很多。
因此把磁盘数据加载到内存读。
把经常访问的数据可以从磁盘读出来放在内存中。

局部性原理：
程序和数据的访问都有聚集成群的倾向，
在一段时间内，仅仅使用其中一小部分（称空间局部性）
或者最近访问过的程序代码和数据，很快又被访问的可能性很大（称时间局部性）

## 磁盘预读（预读的长度一般为页page的整数倍）：
页是存储器的逻辑块
操作系统往往将主存和磁盘分成连续的大小相等的块，每个存储块称为一页（页大小通常为4k），
主存和磁盘以页为大小交换数据。
磁盘预读每次读4k的倍数，一次加载一个磁盘块16k
即便是查一个数据a，加载的也是一个块，而不是只加载a。

## 索引是帮助mysql高效获取数据的数据结构。
索引存储在文件系统中。
索引文件结构：hash，二叉树，b tree， b+tree

hash表的索引格式：
缺点：
1.利用hash存储的话需要将所有的数据文件添加到内存，比较消耗内存空间；
2.如果所有的查询都是等值查询，那么hash确实很快，但是在企业实际工作中范围查找的数据更多，
而不是等值查询；

B树的特点：
所有键值分布在整棵树中，性能接近二分查找；除根节点和叶子节点都是分支节点；所有的叶子结点都在同一层，并以升序排列；
每个节点都有key(键值)、data(数据)、指针；
存储的数据量很大的时候导致深度较大，增大了查询时磁盘io的次数，进而影响性能；

二叉树，BST, AVL, 红黑树，这些树的节点里存的都是一个值。
但是我们索引的时候是从磁盘读数据的，每次返回的是一个数据块
而不是取一个值。
像innodb，myisam每次都是取16k的数据，这样就会取出来很多个节点，
节点越多，树越深，造成io次数变多。
提升IO的效率只有2个途径：
减少IO的次数
减少IO的量（大小）
所以公司一般不让用select * 查询（增大io的量）

B树和B+tree 节点里放的不是一个值而是值的集合：
degree 叫做阶，表示单个节点里可以放置多少个数据元素。
degree = 4 的时候，每个节点可以放3个节点。
一个节点可以放置degree - 1 的数据

myisam和Innodb的数据结构都是b+tree，从上图中可以看到区别是：
Innodb最后的叶子节点存放的是完整数据，这种数据和索引存放在一起的叫做聚簇索引
myisam最后的叶子节点放的是地址，通过地址再查找数据，数据和索引分开存放的叫非聚簇索引

一般创建数据库都是主键自增的，这种适用于单机数据库。
如果是分布式就不能用主键自增，需要用雪花算法设置主键。

# springAop

# redis使用场景和数据类型
缓存 不经常改变的数据，提高访问效率；
redis与数据的双写一致性；
保证缓存的热点数据；
缓存雪崩缓存穿透；

# 消息中间件
注册用户-异步发送邮件短信；

# 全文检索
输入关键词，对关键词分词
全局映射文档，es;


# 接口幂等性
ID token

# 项目中的设计模式
代理模式

# java集合排序

# 去重

# 多线程

# 分布式项目spring-cloud euraka
# 注册集群

# 分布式事务 事务
# hashcode 做什么的
# 服务的熔断降级

# 分布式接口，如何避免表单的重复提交
幂等性
目的： 避免因为各种原因，重复请求导致的业务重复处理；


`对象的相等性`本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的,如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法；
HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。


