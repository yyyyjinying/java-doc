# 运行时数据区
Java虚拟机定义了一系列逻辑数据区域;有些是随着虚拟机的启动而创建，虚拟机的关闭而销毁。还有一部分是随着线程生命周期创建销毁的。
进程（Process）我们可以这样简单的理解，一个应用程序就是一个进程。
线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
在Java虚拟机中堆是所有线程都可以共享的内存区域，是存放所有类实例和数组对象的地方。在虚拟机启动就根据相关堆参数，创建堆，它也是垃圾收集器工作的主要区域。
堆内存里的对象不会被显式的回收，而是由【垃圾回收器回收】，为了配合垃圾收集器的特性我们可以把堆分为年轻代和老年代。
虚拟机栈
虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame，是方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
操作数栈
i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&store memory)，将操作栈栈顶值取出使用，如此线程从操作栈读到的是自增之前的值。
++i：先对局部变量表的 i 自增 1(load memory&add&store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，线程从操作栈读到的是自增之后的值;
动态链接
每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。
方法返回地址
正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；
异常退出;
无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：
返回值压入上层调用栈帧。
异常信息抛给能够处理的栈帧。
PC计数器指向方法调用后的下一条指令。
# 本地方法栈
本地方法（Native Method）：一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。java语言本身无法调用很多的系统资源的，需要JVM和系统打交道，比如操作内存、处理文件、线程调度等。而这部分代码不能用java直接实现，往往是使用C++写的，这类方法就是本地方法。
# 程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器内核都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
# Java堆
栈中new一个对象，指向堆里；
Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存；
# 方法区
是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据一句话总结就是存储元数据地方
JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。
为什么要使用元空间取代永久代的实现？
字符串存在永久代中，容易出现性能问题和内存溢出。
类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
# 垃圾回收
不会再使用的对象，是需要从堆内存清除掉的；当然【栈内存】是不需要清除数据的，栈这种数据结构的特点是，一个数据从栈中弹出，数据自然就被清理掉了，当然【方法区】存有我们的元数据这些数据也是不需要清理的。
回收算法：
​1.引用计数器：给对象添加一引用计数器，被引用一次计数器值就加 1；当引用失效时，计数器值就减 1；计数器为 0 时，对象就是不可能再被使用的，简单高效，缺点是无法解决`对象之间相互循环引用`的问题。
2.可达性分析算法:
通过一系列的称为 "GC Roots" 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有,​ 任何引用链相连时，则证明此对象是不可用的。此算法解决了上述循环引用的问题。
垃圾回收算法:标记-清除算法；复制算法；标记整理算法；分代收集算法
解释型：代码没有编译的过程，读一行执行一行，比如我们以后要学习的javascreipt。
编译型：运行之前需要将代码先编译成【机器指令】，再运行，比如c语言。
在 JVM 中有三个非常重要的编译器
前端编译器：Java 源代码编译为 Java 字节码文件
即时编译器：将 Java 字节码编译为本地机器代码；
AOT编译器：将源代码直接编译为本地机器码；
静态类型语言：在编译时确定；运行时不能修改；
动态类型语言：变量定义时无类型声明的语言，运行时确定和修改；
强类型定义语言和弱类型定义语言
# Java内存模型：
Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。
# 指令重排
代码指令可能并不是严格按照代码语句顺序执行的.大多数现代微处理器都会采用将指令乱序执行的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待。通过乱序执行的技术，处理器可以大大提高执行效率。
# 什么是类加载器？
类加载器就是一段代码【classloader】，他能通过一个类的''全限定名''来获取描述此类的二进制字节流，把字节码文件加载到方法区。然后在堆内（heap）创建一个 java.lang.Class 对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口。
jvm当中有以下几个类加载器，他们负责从不同的classpath下加载字节码文件，classpath就是存放字节码文件的文件目录。
1.【Bootstrap Classloader】启动类加载器，主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。
2.【Extension ClassLoader】扩展类加载器由Java语言实现的，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，开发者可以直接使用标准扩展类加载器。
3.【Application ClassLoader】系统应用类加载器，它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器，就是我们写的代码。
# 双亲委派模型
如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。
启动类加载器（Bootstrap ClassLoader）〈- 扩展类加载器(Extension ClassLoader) 〈- 应用程序类加载器(Application ClassLoader) <- 自定义类加载器()
# 为什么需要双亲委派模型？
如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？`防止内存中出现多份同样的字节码`;
防止重复加载同一个.class；
保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。
# 怎么打破双亲委派模型？
打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。
# 几种主要的JVM参数:
-Xmx3550m： 最大堆大小为3550m。
-Xms3550m： 设置初始堆大小为3550m。
-Xmn2g： 设置年轻代大小为2g。
-Xss128k： 每个线程的堆栈大小为128k。
-XX:MaxPermSize： 设置持久代大小为16m
-XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。
-XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。
# 怎么打出线程栈信息
输入jps，获得进程号。
top -Hp pid 获取本进程中所有线程的CPU耗时性能
jstack pid命令查看当前java进程的堆栈状态
或者 jstack -l > /tmp/output.txt 把堆栈信息打到一个txt文件。
可以使用fastthread 堆栈定位，fastthread.io/
# 强引用、软引用、弱引用、虚引用的区别？
强引用：new了一个对象就是强引用,例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。
软引用： 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。
用处： 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。
（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建
（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出
获取页面进行浏览，浏览完毕后置为软引用，还没有被回收器回收，直接获取，由于内存吃紧，所以对软引用的对象回收了，重新构建；
弱引用： 具有弱引用的对象拥有更短暂的生命周期；在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；
虚引用：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。
# 实例对象的内存分布
标记位： 这里边记录了一些描述对象的信息；
指向类的指针：Java对象的类数据保存在方法区；
数组长度：只有数组对象保存了这部分数据，该数据在32位和64位JVM中长度都是32bit。从这个角度我们也能明白一个数组最长是多长了。
实例数据：对象的实例数据就是成员变量的值，可能是基础数据类型的值可能是引用。
对齐填充字节：因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能。
# 类的加载
1.加载： 
通过全限定类名来获取定义此类的二进制字节流。
将这个字节流所代表的`静态存储结构转化为方法区的运行时数据结构`。
在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口
2.验证：
验证是连接阶段的第一步，这一阶段的目的是为了确保 `Class 文件的字节流中包含的信息符合当前虚拟机的要求`，并且不会危害虚拟机自身的安全。
文件格式验证：如是否以魔数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。
此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。
元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。
第二阶段，保证不存在不符合 Java 语言规范的元数据信息。
字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。
符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。
3.准备
为静态变量分配内存并`设置类变量初始值`，这些变量所使用的内存都将在方法区中进行分配。
4.解析
虚拟机将常量池内的`符号引用替换`为直接引用的过程。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。
5.初始化
​ 到初始化阶段，才真正开始执行编译的指令阶段，此阶段是执行 <clinit>() 方法的过程。<clinit>() 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句合并产生的。（不包括构造器中的语句。构造器是初始化对象的，类加载完成后，创建对象时候将调用的 <init>() 方法来初始化对象）
以上这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用，例如：
1.通过子类引用父类的静态字段，不会导致子类初始化。
2.通过数组定义来引用类，不会触发此类的初始化。MyClass[] cs = new MyClass[10];
3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

# 总结：new一个对象过程中发生了什么？
**确认类元信息是否存在。**当 JVM 接收到 new 指令时，首先在 metaspace 内检查需要创建的类元信息是否存在。 若不存在，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名＋类名为 Key 进行查找对应的 class 文件。 如果没有找到文件，则抛出 ClassNotFoundException 异常 ， 如果找到，则进行类加载（加载 - 验证 - 准备 - 解析 - 初始化），并生成对应的 Class 类对象。
分配对象内存。 首先计算对象占用空间大小，如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小，接着在堆中划分—块内存给新对象。
设定默认值。 成员变量值都需要设定为默认值， 即各种不同形式的零值。
**设置对象头。**设置新对象的哈希码、 GC 信息、锁信息、对象所属的类元信息等。这个过程的具体设置方式取决于 JVM 实现。
执行 init 方法。 初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。
