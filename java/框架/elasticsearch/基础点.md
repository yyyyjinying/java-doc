# 悲观锁与乐观锁机制
为控制并发问题，我们通常采用锁机制。分为悲观锁和乐观锁两种机制。
悲观锁：很悲观，所有情况都上锁。此时只有一个线程可以操作数据。具体例子为数据库中的行级锁、表级锁、读锁、写锁等。
特点：优点是方便，直接加锁，对程序透明。缺点是效率低。
乐观锁：很乐观，对数据本身不加锁。提交数据时，通过一种机制验证是否存在冲突，如es中通过版本号验证。
特点：优点是并发能力高。缺点是操作繁琐，在提交数据时，可能反复重试多次。
多线程获取version如果，相同就重新获取版本号和数据，再重新修改后，比较版本号，如果相同就修改成功。
# es内部基于_version乐观锁控制
es对于文档的增删改都是基于版本号。可以看到版本号依然递增，验证延迟删除策略。如果删除一条数据立马删除的话，所有分片和副本都要立马删除，对es集群压力太大。es内部主从同步时，是多线程异步。乐观锁机制。

# Text analysis文本分析
是将非结构化文本转换为结构化格式的过程;
Elasticsearch在索引或搜索文本字段时执行文本分析。
建立一个搜索引擎,挖掘非结构化数据;
对特定语言进行微调搜索,进行词典或语言研究;

# 倒排索引
Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索;
1.首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有`不重复词条`的`排序列表`，然后列出`每个词条出现在哪个文档`;
2.分词和标准化的过程进行分析，获得相似度高的文档。

# filter与query对比
filter，仅仅只是按照搜索条件过滤出需要的数据而已，不计算任何相关度分数，对相关度没有任何影响。
query，会去计算每个document相对于搜索条件的相关度，并按照相关度进行排序。
应用场景：
一般来说，如果你是在进行搜索，需要将最匹配搜索条件的数据先返回，那么用query 如果你只是要根据一些条件筛选出一部分数据，不关注其排序，那么用filter；
# filter与query性能
filter，不需要计算相关度分数，不需要按照相关度分数进行排序，同时还有内置的自动cache最常使用filter的数据
query，相反，要计算相关度分数，按照分数进行排序，而且无法cache结果
#
在建立索引的时候，一方面会建立倒排索引，以供搜索用；一方面会建立正排索引，也就是doc values，以供排序，聚合，过滤等操作使用

