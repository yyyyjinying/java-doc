响应时间：
并发数：同时处理的请求数量；
并发连接数：
请求数：
并发用户数：
吞吐量：
QPS：每秒请求数；
TPS:每秒事务数；
高性能：快速的访问体验；
高可用：服务一直可以正常访问；
可伸缩：
高可扩展：
安全性：
敏捷性： 
集群：
分布式：
单体架构：
垂直架构：多个单机的架构操作一个数据库，但业务不同，但是有重复的功能比如获取用户信息；
分布式系统：多个服务的消费者服务通过RPC远程调用服务的提供者服务，服务的提供方一旦发生变更，所有的消费方都需要变更；
SOA架构：SOA（Service-OrientedArchitecture），即面向服务的系统架构，是一个组件模型。SOA架构采用广为接受的标准把业务功能封装成标准化的服务，这类服务通过确定的且与最后实现没有关联的接口进行定义[1]。它是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义的接口进行通讯，不涉及底层编程接口和通讯模型，独立于实现服务的硬件平台、操作系统和编程语言。
ESB: 
微服务架构：主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持；业务需要彻底的组件化和服务化，这些运行的小应用，是通过服务完成交互和集成。服务之间一般通过 HTTP 的 RESTfuL API 进行通信协作；

springcloud组件：
服务的注册与发现，注册中心：euraka / zookeeper / consul / nacos
服务负载与调用：ribbon\loadbalance \feign openfeign
服务熔断降级：hystrix \ sentinel[ˈsentɪn(ə)l]
服务路由网关：Gateway
服务分布式配置,配置中心： config / nacos
消息总线： bus / nacos
服务开发spring-boot：

①Spring Cloud 是一系列框架的有序集合。
②Spring Cloud 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来。
③通过 Spring Boot 风格进行再封装,屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。
④它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、 断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。
⑥Spring Cloud 版本命名方式采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如：最早的Release版本：Angel，第二个Release版本：Brixton，然后是Camden、Dalston、Edgware，Finchley，Greenwich，Hoxton。
相同点：Spring Cloud 与 Dubbo 都是实现微服务有效的工具。
不同点：1Dubbo 只是实现了服务治理，而 Spring Cloud 子项目分别覆盖了微服务架构下的众多部件。2Dubbo 使用 RPC 通讯协议，Spring Cloud 使用 RESTful 完成通信，Dubbo 效率略高于 Spring Cloud。
微服务就是将项目的各个模块拆分为可独立运行、部署、测试的架构设计风格。
Spring 公司将其他公司中微服务架构常用的组件整合起来，并使用 SpringBoot 简化其开发、配置。称为 Spring Cloud。
Spring Cloud 与 Dubbo都是实现微服务有效的工具。Dubbo 性能更好，而 Spring Cloud 功能更全面。Dubbo 已经融入到spingcloudAlibaba这一套

# RestTemplate
Spring提供的一种简单便捷的模板类，用于在 java 代码里访问 restful 服务。其功能与 HttpClient 类似，但是 RestTemplate 实现更优雅，使用更方便。
# Eureka 
是 Netflix 公司开源的一个服务注册与发现的组件 。
Eureka 包含两个组件：Eureka Server (注册中心) 和 Eureka Client (服务提供者、服务消费者)。
Greenwich.RELEASE的版本
```pom
<!-- eureka-server -->
<dependency>
<groupId>org.springframework.cloud</groupId>
<artifactId>
    spring-cloud-starter-netflix-eureka-server
    <!-- spring-cloud-starter-netflix-eureka-client -->
</artifactId>
@EnableEurekaServer
@EnableEurekaClient
@EnableDiscoveryClient
配置信息有：配置eureka服务的配置地址，将来客户端使用该地址和euraka通信；是否重euraka抓取地址；是否将自己的路径注册到eureka;client向eureka server发送的心跳时间间隔；如果sever间隔多少没有收到client的心跳包，则剔除该服务；检查服务的时间间隔；
euraka仪表盘dashboard；
client:
    service-url:
      defaultZone: http://eureka-server1:8761/eureka,http://eureka-server2:8762/eureka # Eureka Client 分别注册到这两个 Eureka Server中

```
Consumer 服务 通过从 Eureka Server 中抓取 Provider 地址，完成远程调用
```java
@Autowired
private DiscoveryClient discoveryClient;
//服务发现
List<ServiceInstance> instances = discoveryClient.getInstances("EUREKA-PROVIDER");
//通过某个策略拿到一个实例
ServiceInstance serviceInstance = instances.get(0);
String host = serviceInstance.getHost();
int port = serviceInstance.getPort();
String url="http://"+host+":"+port+"/goods/findById/"+id;
Goods goods = restTemplate.getForObject(url, Goods.class);
```

# Zookeeper服务注册与发现
zookeeper是一个分布式协调工具，可以实现注册中心功能。dubbo,大数据组件hadoop,hive,kafka。
```pom
<!--springcloud 整合 zookeeper 组件-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <!--zk发现-->
        <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.apache.zookeeper</groupId>
                <artifactId>zookeeper</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.apache.zookeeper</groupId>
        <artifactId>zookeeper</artifactId>
        <version>3.4.9</version>
        <exclusions>
            <exclusion>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-log4j12</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
spring:
  application:
    name: zookeeper-provider
  cloud:
    zookeeper:
      connect-string: 127.0.0.1:2181 # zk地址

提供者和消费者的主启动类都要添加
@SpringBootApplication
@EnableDiscoveryClient //开启发现客户端
```

# Consul服务注册与发现
Consul 是由 HashiCorp 基于 GoLanguage 语言开发的，支持多数据中心，分布式高可用的服务发布和注册服务软件。用于实现分布式系统的服务发现与配置。
```pom
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency>
spring:
  application:
    name: consul-provider
  cloud:
    consul:
      host: 127.0.0.1
      port: 8500
      discovery:
        service-name: ${spring.application.name}
@SpringBootApplication
@EnableDiscoveryClient
```
三个注册中心的异同
组件	语言	cap	健康检查	暴露接口	cloud集成
eureka	java	ap	支持	http	已经集成
zookeeper	java	cp	支持	tcp	已经集成
consul	go	cp	支持	http	已经集成

# Ribbon负载均衡服务调用
Netflix公司推出的http和TCP的客户端负载均衡工具;
简化远程调用代码;
内置很多负载均衡算法;

服务端负载均衡：ribbon
客户端负载均衡: nginx

新版的eureka依赖以及集成了Ribbon依赖，可以不引用
```pom
<!--Ribbon的依赖-->
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
 </dependency>
```
如何使用：
声明restTemplate时@LoadBalanced；
restTemplate请求远程服务时，ip端口替换为服务名；
```java
@LoadBalanced
@RestTemplate restTemplate;
String url="http://EUREKA-PROVIDER/goods/findById/"+id;
Goods goods = restTemplate.getForObject(url, Goods.class);
```
## ribbon 负载均衡策略
RoundRobinRule: 简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。
AvailabilityFilteringRule:	
    对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。注意：可以通过修改配置loadbalancer.<clientName>.connectionFailureCountThreshold来修改连接失败多少次之后被设置为短路状态。默认是3次。（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上线，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。
WeightedResponseTimeRule: 为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。
ZoneAvoidanceRule: 以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。
BestAvailableRule: 忽略哪些短路的服务器，并选择并发数较低的服务器。
RandomRule:	随机选择一个可用的服务器。
Retry: 重试机制的选择逻辑
## 默认是轮询策略手动设置
调用不同的其他微服务时，可以采用不同的策略。
启动类 @RibbonClient(name ="EUREKA-PROVIDER",configuration = MyRule.class)
```yml
EUREKA-PROVIDER: #远程服务名
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #策略
```
# OpenFeign服务接口调用
Feign 是一个声明式的 REST 客户端，它用了基于接口的注解方式，很方便实现客户端像调用本地接口方法一样，进行远程调用。
Feign 最初由 Netflix 公司提供，但不支持SpringMVC注解，后由 SpringCloud 对其封装，支持了SpringMVC注解，让使用者更易于接受。
```pom
在消费端引入 open-feign 依赖，以及在`启动类加上@EnableFeignClients 注解`；
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```
## 如果使用
编写Feign调用接口。复制粘贴被调方的conreoller方法,加上类路径。
```java
// GoodsFeign 接口注解
@FeignClient("EUREKA-PROVIDER")
public interface GoodsFeign {
    @GetMapping("/goods/findById/{id}")
    public Goods findById(@PathVariable("id") Integer id);
}
// @FeignClient标签的常用属性如下：
// name：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现
// url: url一般用于调试，可以手动指定@FeignClient调用的地址
// decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignException
// configuration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contract
// fallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口
// fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码
// path: 定义当前FeignClient的统一前缀，当我们项目中配置了server.context-path,server.servlet-path时使用

@Autowired
GoodsFeign goodsFeign;
Goods goods = goodsFeign.findById(id);
```

## Feign 底层依赖于 Ribbon 实现负载均衡和远程调用
Feign 只能记录 debug 级别的日志信息
设置Ribbon的超时时间
```yml
ribbon:
  ConnectTimeout: 1000 # 连接超时时间 默认1s
  ReadTimeout: 3000 # 逻辑处理的超时时间 默认1s
```

# 服务熔断和降级 - Hystrix断路器
重点：能让服务的调用方，够快的知道被调方挂了！不至于说让用户在等待。
`Hystix` 是 Netflix 开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败（雪崩）。
雪崩：一个服务失败，导致整条链路的服务都失败的情形。
线程池隔离： 使用了hystrix,更细分线程池，只需要重试40次，让a更快的知道c挂了
信号量隔离： 
降级： fallback和fallbackMethod (回退)
- 服务提供方降级(异常，超时)；
```pom
在服务提供方，引入 hystrix 依赖
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
```
```java
    /** 定义降级方法   返回特殊对象
     *  1方法的返回值要和原方法一致
     *  2方法参数和原方法一样
     */
    public Goods findById_fallback(Integer id){
        Goods goods=new Goods();
        goods.setGoodId(-1);
        goods.setTitle("provider提供方降级！");
        goods.setPrice(-9.9);
        goods.setStock(-10);

        return goods;
    }
@GetMapping("/findById/{id}")
// 使用 @HystrixCommand 注解配置降级方法
    @HystrixCommand(fallbackMethod = "findById_fallback",commandProperties = {
            //设置Hystrix的超时时间，默认1s
            @HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value = "3000")
    })
    public Goods findById(@PathVariable("id") Integer id){}
```

- 消费方降级： 
feign 组件已经集成了 hystrix 组件
```yml
feign:
  hystrix:
    enabled: true
```
```java
@Component
public class GoodsFeignCallback implements GoodsFeign{
    @Override
    public Goods findById(Integer id) {
        Goods goods=new Goods();
        goods.setGoodId(-2);
        goods.setTitle("调用方降级了！");
        goods.setPrice(-5.5);
        goods.setStock(-5);
        return goods;
    }
}
@FeignClient(
    value = "EUREKA-PROVIDER",
    configuration = FeignLogConfig.class,
    fallback = GoodsFeignCallback.class
)
public interface GoodsFeign {
    @GetMapping("/goods/findById/{id}")
    public Goods findById(@PathVariable("id") Integer id);
}
```

熔断：Hyst rix 熔断机制，用于监控微服务调用情况，当失败的情况达到预定的阈值（5秒失败20次），会打开断路器，拒绝所有请求，直到服务恢复正常为止。
```java
@HystrixCommand(fallbackMethod = "findOne_fallback",commandProperties = {
            //设置Hystrix的超时时间，默认1s
            @HystrixProperty(name="execution.isolation.thread.timeoutInMilliseconds",value = "3000"),
            //监控时间 默认5000 毫秒
            @HystrixProperty(name="circuitBreaker.sleepWindowInMilliseconds",value = "5000"),
            //失败次数。默认20次
            @HystrixProperty(name="circuitBreaker.requestVolumeThreshold",value = "20"),
            //失败率 默认50%
            @HystrixProperty(name="circuitBreaker.errorThresholdPercentage",value = "50")

    })
```
限流：是有限流，但是，项目一般不用。nginx或者网关限流。

# Turbine聚合监控
引入Turbine聚合监控起步依赖
```pom
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-turbine</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```
```yml
turbine:
  combine-host-port: true
  # 配置需要监控的服务名称列表
  app-config: EUREKA-PROVIDER,EUREKA-CONSUMER
  cluster-name-expression: "'default'"
  aggregator:
    cluster-config: default
  #instanceUrlSuffix: /actuator/hystrix.stream
hystrix:
  dashboard:
    proxy-stream-allow-list: "*"
```
```java
@SpringBootApplication
@EnableEurekaClient
@EnableTurbine //开启Turbine 很聚合监控功能
@EnableHystrixDashboard //开启Hystrix仪表盘监控功能
```
# Gateway路由网关
功能：路由+过滤
存在的问题：
1、客户端需要记录不同微服务地址，增加客户端的复杂性
2、每个后台微服务都需要认证
3、http 发请求，涉及到跨域
4、后台新增微服务，不能动态知道地址

网关旨在为微服务架构提供一种简单而有效的统一的API路由管理方式；
在微服务架构中，不同的微服务可以有不同的网络地址，各个微服务之间通过互相调用完成用户请求，客户端可能通过调用N个微服务的接口完成一个用户请求。
网关就是系统的入口，封装了应用程序的内部结构，为客户端提供统一服务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、缓存、负载均衡、流量管控、路由转发等

在目前的网关解决方案里，有Nginx+ Lua、Netflix Zuul/zuul2 、Spring Cloud Gateway等等
Gateway 支持过滤器功能，对请求或响应进行拦截，完成一些通用操作;
Gateway 提供两种过滤器方式：“pre”和“post”
pre 过滤器，在转发之前执行，可以做参数校验、权限校验、流量监控、日志输出、协议转换等。
post 过滤器，在响应之前执行，可以做响应内容、响应头的修改，日志的输出，流量监控等。
GatewayFilter：局部过滤器，针对单个路由
GlobalFilter ：全局过滤器，针对所有路由
内置的过滤器工厂:
AddRequestHeader	为原始请求添加Header	Header的名称及值
AddRequestParameter	为原始请求添加请求参数	参数名称及值
AddResponseHeader	为原始响应添加Header	Header的名称及值
DedupeResponseHeader	剔除响应头中重复的值	需要去重的Header名称及去重策略
Hystrix	为路由引入Hystrix的断路器保护	HystrixCommand的名称
FallbackHeaders	为fallbackUri的请求头中添加具体的异常信息	Header的名称
PrefixPath	为原始请求路径添加前缀	前缀路径
PreserveHostHeader	为请求添加一个preserveHostHeader=true的属性，路由过滤器会检查该属性以决定是否要发送原始的Host	无
RequestRateLimiter	用于对请求限流，限流算法为令牌桶	keyResolver、rateLimiter、statusCode、denyEmptyKey、emptyKeyStatus
RedirectTo	将原始请求重定向到指定的URL	http状态码及重定向的url
RemoveHopByHopHeadersFilter	为原始请求删除IETF组织规定的一系列Header	默认就会启用，可以通过配置指定仅删除哪些Header
RemoveRequestHeader	为原始请求删除某个Header	Header名称
RemoveResponseHeader	为原始响应删除某个Header	Header名称
RewritePath	重写原始的请求路径	原始路径正则表达式以及重写后路径的正则表达式
RewriteResponseHeader	重写原始响应中的某个Header	Header名称，值的正则表达式，重写后的值
SaveSession	在转发请求之前，强制执行WebSession::save操作	无
secureHeaders	为原始响应添加一系列起安全作用的响应头	无，支持修改这些安全响应头的值
SetPath	修改原始的请求路径	修改后的路径
SetResponseHeader	修改原始响应中某个Header的值	Header名称，修改后的值
SetStatus	修改原始响应的状态码	HTTP 状态码，可以是数字，也可以是字符串
StripPrefix	用于截断原始请求的路径	使用数字表示要截断的路径的数量
Retry	针对不同的响应进行重试	retries、statuses、methods、series
RequestSize	设置允许接收最大请求包的大小。如果请求包大小超过设置的值，则返回 413 Payload Too Large	请求包大小，单位为字节，默认值为5M
ModifyRequestBody	在转发请求之前修改原始请求体内容	修改后的请求体内容
ModifyResponseBody	修改原始响应体的内容	修改后的响应体内容
Default	为所有路由添加过滤器	过滤器工厂名称及值
```yml
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        filters:
        - AddRequestHeader=X-Request-Foo, Bar # X-Request-Foo=Bar
        # - AddRequestParameter=foo, bar # foo=bar
        # 若需要去重的Header有多个，使用空格分隔
        # - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origi
```
Modify Request Body GatewayFilter Factory
在转发请求之前修改原始请求体内容，该过滤器工厂只能通过代码配置，不支持在配置文件中配置
Modify Response Body GatewayFilter Factory
可用于修改原始响应体的内容，该过滤器工厂同样只能通过代码配置，不支持在配置文件中配置

# 为什么使用Alibaba
spring netflix进入维护模式
什么是维护模式：spring cloud团队将不会再向模块添加新功能，我们将修复block级别的bug以及安全问题，我们也会考虑并审查社区的小型pull request。我们打算继续支持这些模块，知道Greenwich版本被普遍采用至少一年
SpringCloud Netflix将不再开发新的组件
2018.10.31，spring cloud Alibaba正式入驻了Spring Cloud官方孵化器，并在Maven中央库发布了第一个版本
# 主要功能：
服务限流降级：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。
服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。
消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。
分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。。
阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。
分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。
阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。
# 组件：
Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。
Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。
Dubbo：Apache Dubbo™ 是一款高性能 Java RPC 框架。
Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。
Alibaba Cloud OSS: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。
Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。
Alibaba Cloud SMS: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。
##  nacos(Naming Configuration Service)：服务注册和配置中心
Nacos = Eureka + Config + Bus
替代Eureka做服务注册中心
替代Config做服务配置中心
配置变更是调整系统运行时行为的有效手段。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项;
配置快照 Nacos 的客户端 SDK 会在本地生成配置的快照。当客户端无法连接到 Nacos Server 时，可以使用配置快照显示系统的整体容灾能力。配置快照类似于 Git 中的本地 commit，也类似于缓存，会在适当的时机更新，但是并没有缓存过期（expiration）的概念。
服务 通过预定义接口网络访问的提供给客户端的软件功能。
服务名 服务提供的标识，通过该标识可以唯一确定其指代的服务。
服务注册中心 存储服务实例和服务负载均衡策略的数据库。
服务发现 在计算机网络上，（通常使用服务名）对服务下的实例的地址和元数据进行探测，并以预先定义的接口提供给客户端进行查询。
元信息 Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。
服务分组 不同的服务可以归类到同一分组。
虚拟集群 同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群。
实例 提供一个或多个服务的具有可访问网络地址（IP:Port）的进程。
权重 实例级别的配置。权重为浮点数。权重越大，分配给该实例的流量越大。
健康检查 以指定方式检查服务下挂载的实例 (Instance) 的健康度，从而确认该实例 (Instance) 是否能提供服务。根据检查结果，实例 (Instance) 会被判断为健康或不健康。对服务发起解析请求时，不健康的实例 (Instance) 不会返回给客户端。
健康保护阈值 为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个 0 到 1 之间的浮点数。当域名健康实例数 (Instance) 占总服务实例数 (Instance) 的比例小于该值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群中剩余健康实例 (Instance) 能正常工作。

服务注册与服务框架	CAP模型	控制台管理	社区活跃度
Eureka	AP高可用	支持	低(2.x版本闭源)
Zookeeper	CP一致	支持	中
Consul	CP	支持	高
Nacos	AP+CP可以自由切换	支持	高
```yml
spring:
  application:
    name: nacos-provider
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
```
@EnableDiscoveryClient

@RestController
@RefreshScope // 开启刷新功能
@RequestMapping("/goods")
public class DemoController {}
<!--支持注册中心-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>

<!-- 支持配置中心 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>

A：可用性 
C：一致性 
P：分区容错性
Nacos默认AP，dataid、group、namespace 三者关系如下：（不同的dataid，是相互独立的，不同的group是相互隔离的，不同的namespace也是相互独立的）；Nacos定义为一个IDC内部应用组件，并非面向公网环境的产品；
Nacos支持三种部署模式
单机模式 - 用于测试和单机试用。
集群模式 - 用于生产环境，确保高可用。
多集群模式 - 用于多数据中心场景。
# Sentinel实现熔断与限流
就是hystrix的替代
Sentinel 具有以下特征:
丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。
完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。
广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java/Go/C++ 等多语言的原生实现。
完善的 SPI 扩展机制：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。

# QPS（Queries-per-second 每秒钟的请求数量）：
当调用该api就QPS达到阈值的时候，进行限流
是否集群：不需要集群
## 流控模式：
直接：api达到限流条件时，直接限流。分为QPS和线程数
关联：当关联的资到阈值时，就限流自己。别人惹事，自己买单
链路：只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】
## 流控效果：
快速失败：直接抛异常 Blocked by Sentinel (flow limiting)
warm up热身预热：根据codeFactor（冷加载因子，默认3）的值，从阈值codeFactor，经过预热时长，才达到设置的QPS阈值
排队等待：匀速排队，让请求以均匀的速度通过，阈值类型必须设置为QPS,否则无效

# warm up
它从开始阈值到最大QPS阈值会有一个缓冲阶段，一开始的阈值是最大QPS阈值的1/3，然后慢慢增长，直到最大阈值，适用于将突然增大的流量转换为缓步增长的场景。
Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。详细文档可以参考 流量控制 - Warm Up 文档，具体的例子可以参见 WarmUpFlowDemo。

# 熔断降级
我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。
熔断策略
Sentinel 提供以下几种熔断策略：

慢调用比例 (SLOW_REQUEST_RATIO)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。
异常比例 (ERROR_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。
异常数 (ERROR_COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。

a.熔断：微服务自己限流，不可用了。
b.降级：调用方，提供方错了，返回给客户一个友好对象。



# Dubbo
阿里巴巴开源的java RPC框架；
多版本：灰度发布；
超时机制，重试机制；
服务降级：


3.1.5	Dubbo3 最新稳定版本，建议所有的 3.x 用户都升级到该版本。

Dubbo 作为服务开发框架解决了业务应用中微服务定义、暴露、通信与治理的问题，为业务应用开发定义了一套微服务编程范式。 具体来说，Dubbo 为业务应用提供了微服务开发API、RPC 协议、服务治理三大核心能力，让开发者真正的专注业务逻辑开发。
Dubbo 不是应用框架的替代者，它可以很好的工作在每种语言的主流编程框架之上，以 Java 为例，Dubbo 可以很好的与 Spring 协作，并在此基础上提供服务定义、微服务编程、服务发现、负载均衡、流量管控等能力。
# 核心概念和架构
从抽象架构上分为两层：服务治理抽象控制面 和 Dubbo 数据面 。
服务治理控制面。服务治理控制面不是特指如注册中心类的单个具体组件，而是对 Dubbo 治理体系的抽象表达。控制面包含协调服务发现的注册中心、流量管控策略、Dubbo Admin 控制台等，如果采用了 Service Mesh 架构则还包含 Istio 等服务网格控制面。
Dubbo 数据面。数据面代表集群部署的所有 Dubbo 进程，进程之间通过 RPC 协议实现数据交换，Dubbo 定义了微服务应用开发与调用规范并负责完成数据传输的编解码工作。
服务消费者 (Dubbo Consumer)，发起业务调用或 RPC 通信的 Dubbo 进程
服务提供者 (Dubbo Provider)，接收业务调用或 RPC 通信的 Dubbo 进程
Dubbo 作为 服务开发框架 约束了微服务定义、开发与调用的规范，定义了服务治理流程及适配模式
Dubbo 作为 RPC 通信协议实现 解决服务间数据传输的编解码问题
Dubbo 从设计上不绑定任何一款特定通信协议，HTTP/2、REST、gRPC、JsonRPC、Thrift、Hessian2 等几乎所有主流的通信协议，Dubbo 框架都可以提供支持。
Dubbo 对通信协议的支持具有以下特点：

不绑定通信协议
提供高性能通信协议实现
支持流式通信模型
不绑定序列化协议
支持单个服务的多协议暴露
支持单端口多协议发布
支持一个应用内多个服务使用不同通信协议
# 服务治理
服务开发框架解决了开发与通信的问题，但在微服务集群环境下，我们仍需要解决无状态服务节点动态变化、外部化配置、日志跟踪、可观测性、流量管理、高可用性、数据一致性等一系列问题，我们将这些问题统称为服务治理。
# 服务治理功能定义
地址发现
负载均衡: Dubbo 默认提供加权随机、加权轮询、最少活跃请求数优先、最短响应时间优先、一致性哈希和自适应负载等策略
# 流量路由
Dubbo 支持通过一系列流量规则控制服务调用的流量分布与行为，基于这些规则可以实现基于权重的比例流量分发、灰度验证、金丝雀发布、按请求参数的路由、同区域优先、超时配置、重试、限流降级等能力。

# 链路追踪
Dubbo 官方通过适配 OpenTelemetry 提供了对 Tracing 全链路追踪支持，用户可以接入支持 OpenTelemetry 标准的产品如 Skywalking、Zipkin 等。另外，很多社区如 Skywalking、Zipkin 等在官方也提供了对 Dubbo 的适配。

# 可观测性
Dubbo 实例通过 Prometheus 等上报 QPS、RT、请求次数、成功率、异常次数等多维度的可观测指标帮助了解服务运行状态，通过接入 Grafana、Admin 控制台帮助实现数据指标可视化展示。

spring应用框架-》 spring boot微服务框架 -〉 spring cloud服务治理
dubbo服务开发&治理
Dubbo 和 Spring Cloud 都侧重在对分布式系统中常见问题模式的抽象（如服务发现、负载均衡、动态配置等），同时对每一个问题都提供了配套组件实现，形成了一套微服务整体解决方案，让使用 Dubbo 及 Spring Cloud 的用户在开发微服务应用时可以专注在业务逻辑开发上。
Spring Cloud 的优势在于：

同样都支持 Spring 开发体系的情况下，Spring Cloud 得到更多的原生支持
对一些常用的微服务模式做了抽象如服务发现、动态配置、异步消息等，同时包括一些批处理任务、定时任务、持久化数据访问等领域也有涉猎。
基于 HTTP 的通信模式，加上相对比较完善的入门文档和演示 demo 和 starters，让开发者在第一感觉上更易于上手
Spring Cloud 的问题有：
只提供抽象模式的定义不提供官方稳定实现，开发者只能寻求类似 Netflix、Alibaba、Azure 等不同厂商的实现套件，而每个厂商支持的完善度、稳定性、活跃度各异
有微服务全家桶却不是能拿来就用的全家桶，demo 上手容易，但落地推广与长期使用的成本非常高
欠缺服务治理能力，尤其是流量管控方面如负载均衡、流量路由方便能力都比较弱
编程模型与通信协议绑定 HTTP，在性能、与其他 RPC 体系互通上存在障碍
总体架构与实现只适用于小规模微服务集群实践，当集群规模增长后就会遇到地址推送效率、内存占用等各种瓶颈的问题，但此时迁移到其他体系却很难实现
很多微服务实践场景的问题需要用户独自解决，比如优雅停机、启动预热、服务测试，再比如双注册、双订阅、延迟注册、服务按分组隔离、集群容错等
都是 Dubbo 的优势所在：

完全支持 Spring & Spring Boot 开发模式，同时在服务发现、动态配置等基础模式上提供与 Spring Cloud 对等的能力。
是企业级微服务实践方案的整体输出，Dubbo 考虑到了企业微服务实践中会遇到的各种问题如优雅上下线、多注册中心、流量管理等，因此其在生产环境的长期维护成本更低
在通信协议和编码上选择更灵活，包括 rpc 通信层协议如 HTTP、HTTP/2(Triple、gRPC)、TCP 二进制协议、rest等，序列化编码协议Protobuf、JSON、Hessian2 等，支持单端口多协议。
Dubbo 从设计上突出服务服务治理能力，如权重动态调整、标签路由、条件路由等，支持 Proxyless 等多种模式接入 Service Mesh 体系
高性能的 RPC 协议编码与实现，
Dubbo 是在超大规模微服务集群实践场景下开发的框架，可以做到百万实例规模的集群水平扩容，应对集群增长带来的各种问题
`Dubbo 提供 Java 外的多语言实现，使得构建多语言异构的微服务体系成为可能`
# Dubbo 与 gRPC 最大的差异在于两者的定位上：
gRPC 定位为一款 RPC 框架，Google 推出它的核心目标是定义云原生时代的 rpc 通信规范与标准实现;
Dubbo 定位是一款微服务开发框架，它侧重解决微服务实践从服务定义、开发、通信到治理的问题，因此 Dubbo 同时提供了 RPC 通信、与应用开发框架的适配、服务治理等能力。
Dubbo 不绑定特定的通信协议，即 Dubbo 服务间可通过多种 RPC 协议通信并支持灵活切换。因此，你可以在 Dubbo 开发的微服务中选用 gRPC 通信，Dubbo 完全兼容 gRPC，并将 gRPC 设计为内置原生支持的协议之一。
gRPC 更适合作为底层的通信协议规范或编解码包，Dubbo 则可用作微服务整体解决方案;\
# 构建可伸缩的微服务集群
流量管控
在地址发现和负载均衡机制之外，Dubbo 丰富的流量管控规则可以控制服务间的流量走向和 API 调用，基于这些规则可以实现在运行期动态的调整服务行为如超时时间、重试次数、限流参数等，通过控制流量分布可以实现 A/B 测试、金丝雀发布、多版本按比例流量分配、条件匹配路由、黑白名单等，提高系统稳定性。
动态调整超时时间
服务重试
访问日志
同区域优先
灰度环境隔离
参数路由
按权重比例分流
金丝雀发布
服务降级
实例临时拉黑
指定机器导流
# 服务网格
基于 Dubbo 开发的服务可以透明的接入 Istio 等服务网格体系，Dubbo 支持基于 Envoy 的流量拦截方式，也支持更加轻量的 Proxyless Mesh 部署模式。

# service 与 reference
service 与 reference 是 Dubbo 最基础的两个配置项，它们用来将某个指定的接口或实现类注册为 Dubbo 服务，并通过配置项控制服务的行为。

service 用于服务提供者端，通过 service 配置的接口和实现类将被定义为标准的 Dubbo 服务，从而实现对外提供 RPC 请求服务。
reference 用于服务消费者端，通过 reference 配置的接口将被定义为标准的 Dubbo 服务，生成的 proxy 可发起对远端的 RPC 请求。
# consumer 与 provider
当应用内有多个 reference 配置时，consumer 指定了这些 reference 共享的默认值，如共享的超时时间等以简化繁琐的配置，如某个 reference 中单独设置了配置项值则该 reference 中的配置优先级更高。
当应用内有多个 service 配置时，provider 指定了这些 service 共享的默认值，如某个 service 中单独设置了配置项值则该 service 中的配置优先级更高。
consumer 组件还可以对 reference 进行虚拟分组，不通分组下的 reference 可有不同的 consumer 默认值设定；如在 XML 格式配置中，<dubbo:reference /> 标签可通过嵌套在 <dubbo:consumer /> 标签之中实现分组。provider 与 service 之间也可以实现相同的效果。

注解有 @DubboService、@DubboReference 与 EnableDubbo。其中 @DubboService 与 @DubboReference 用于标记 Dubbo 服务，EnableDubbo 启动 Dubbo 相关配置并指定 Spring Boot 扫描包路径。
配置文件 application.properties 或 application.yml

# 启动时检查
Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check="true"。
可以通过 check="false" 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check="false"，总是会返回引用，当服务恢复时，能自动连上。
## 使用场景
单向依赖：有依赖关系（建议默认设置）和无依赖关系（可以设置 check=false）
相互依赖：即循环依赖，(不建议设置 check=false)
延迟加载处理
`check 只用来启动时检查，运行时没有相应的依赖仍然会报错`
# 响应式编程
基于 Triple 协议和 Project Reactor 实现，3.1.0 版本以上支持用户仅需编写 IDL 文件，并指定 protobuf 插件的相应 Generator，即可生成并使用支持响应式API的 Stub 代码。
有四种调用模式，分别是 OneToOne、OneToMany、ManyToOne、ManyToMany，分别对应 Unary调用、服务端流、客户端流、双向流。在 Reactor 的实现中，One 对应 Mono，Many 对应 Flux。
Reactive Stream 提供了一套标准的异步流处理 API， 在能够让应用写出事件驱动的程序的同时，也通过 BackPressure 的方式保证了节点的稳定。Triple 协议在通信协议层面为 Dubbo 框架增加了流式场景的支持，在此基础上能够实现上层包括大文件传输和推送机制的业务需求。Dubbo + Reactive Stream Stub 的组合模式可以给用户带来最方便的流式使用方式以及全链路异步性能提升
## 使用场景
系统需要处理大量并发请求而不会使任何服务器过载。大量用户提供实时数据的系统，希望确保系统能够处理负载而不会崩溃或变慢。
# 参数校验
参数验证功能是基于 JSR303 实现的，用户只需标识 JSR303 标准的验证 annotation，并通过声明 filter 来实现验证

# 服务分组
同一个接口针对不同的业务场景、不同的使用需求或者不同的功能模块等场景，可使用服务分组来区分不同的实现方式。同时，这些不同实现所提供的服务是可并存的，也支持互相调用。
使用场景
当一个接口有多种实现时，可以用 group 区分。一个接口，分组实现，消费一个接口分组调用；
# 集群容错
在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。
各节点关系：
这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息
Directory 代表多个 Invoker，可以把它看成 List<Invoker> ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更
Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个
Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等
LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选
通过使用服务注册表和负载平衡，可以提高集群提供的容错能力，服务注册表用于存储有关可用服务及其位置的信息，负载平衡用于确保请求均匀分布在集群中的所有服务器上，如果一台服务器发生故障，负载将转移到其他可用服务器。
配置监视集群中服务器运行状况的运行状况检查，如果服务器未通过运行状况检查，则可以将其从集群中删除，并将负载转移到其余服务器，确保集群正常运行，并且用户可以使用应用程序。
使用场景
多个服务器部署同一集群中，运行同一应用程序，如果一台服务器出现故障，其他服务器将接管负载，确保应用程序对用户仍然可用
可以自行扩展集群容错策略 集群扩展
## 在服务提供方和消费方配置集群模式
<dubbo:service cluster="failsafe" />
<dubbo:reference cluster="failsafe" />
Failfast Cluster: 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
Failsafe Cluster: 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
Failback Cluster: 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
Forking Cluster: 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。
Broadcast Cluster: 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。
# 服务降级(避免雪崩)
服务降级是指服务在非正常情况下进行降级应急处理。
使用场景
某服务或接口负荷超出最大承载能力范围，需要进行降级应急处理，避免系统崩溃
调用的某非关键服务或接口暂时不可用时，返回模拟数据或空，业务还能继续可用
降级非核心业务的服务或接口，腾出系统资源，尽量保证核心业务的正常运行
某上游基础服务超时或不可用时，执行能快速响应的降级预案，避免服务整体雪崩






# 分组聚合
通过分组对结果进行聚合并返回聚合后的结果，比如菜单服务，用 group 区分同一接口的多种实现，现在消费方需从每种 group 中调用一次并返回结果，对结果进行合并之后返回，这样就可以实现聚合菜单项。

# 服务分版本
在低压力时间段，先升级一半提供者为新版本
再将所有消费者升级为新版本
然后将剩下的一半提供者升级为新版本
配置 
新老版本服务提供者
新老版本服务消费者
使用场景: 当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。

# 权限控制
通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者， 可以防止消费者绕过注册中心访问提供者， 另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者。

在一定程度上实现客户端和服务端的可信鉴权，避免任意客户端都可以访问，降低出现安全问题的风险。
<!--固定token令牌，相当于密码-->
<dubbo:provider token="123456" />
<!--随机token令牌，使用UUID生成-->
<dubbo:provider token="true" />
<!--随机token令牌，使用UUID生成-->
<dubbo:service interface="com.foo.BarService" token="true" />
<!--固定token令牌，相当于密码-->
<dubbo:service interface="com.foo.BarService" token="123456" />

# 主机地址自定义暴露
使用场景
应用程序包含多个服务每个服务定制地址，外部客户端通过定制的地址访问服务。
应用程序同一服务的多个版本每个版本的服务定制地址，外部客户端通过定制的地址访问相应版本的服务。
应用程序多个地区部署服务每个地区定制地址，外部客户端通过定制的地址访问相应地区的相应服务。
可以通过dubbo.protocol或dubbo.provider的host属性对host进行配置,支持IP地址和域名.但此时注册到注册中心的IP地址和监听IP地址是同一个值
为了解决在虚拟环境或局域网内consumer无法与provider通信的问题,可以通过环境变量分别设置注册到注册中心的IP地址和监听IP地址,其优先级高于dubbo.protocol或dubbo.provider的host配置

environment:
- "DUBBO_IP_TO_REGISTRY=192.168.1.3" 注册到注册中心的 ip 地址
- "DUBBO_PORT_TO_REGISTRY=20887" 注册到注册中心的 port 端口
- "DUBBO_IP_TO_BIND=192.168.1.3" 监听 ip 地址
- "DUBBO_PORT_TO_BIND=8088" 监听 port 端口

# 优雅停机

# 延迟暴露
如果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。我们在 Dubbo 2.6.5 版本中对服务延迟暴露逻辑进行了细微的调整，将需要延迟暴露（delay > 0）服务的倒计时动作推迟到了 Spring 初始化完成后进行。你在使用 Dubbo 的过程中，并不会感知到此变化，因此请放心使用。

当服务完全配置并准备好向外界暴露时才会触发服务的暴露，保证服务在准备就绪时暴露，提高了服务系统可靠性。

强烈建议不要在服务的实现类中有 applicationContext.getBean() 的调用，全部采用 IoC 注入的方式使用 Spring的Bean。
如果实在要调 getBean()，可以将 Dubbo 的配置放在 Spring 的最后加载。
如果不想依赖配置顺序，可以使用 <dubbo:provider delay=”-1” />，使 Dubbo 在 Spring 容器初始化完后，再暴露服务。
如果大量使用 getBean()，相当于已经把 Spring 退化为工厂模式在用，可以将 Dubbo 的服务隔离单独的 Spring 容器。

# 异步调用
Dubbo 的所有异步编程接口开始以 CompletableFuture 为基础
基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。
使用场景
将用户请求内容发送到目标请求，当目标请求遇到高流量或需要长时间处理，异步调用功能将允许立即向用户返回响应，同时目标请求继续后台处理请求，当目标请求返回结果时，将内容显示给用户。
使用方式
使用 CompletableFuture 签名的接口
需要服务提供者事先定义 CompletableFuture 签名的服务，接口定义指南如下：

Provider端异步执行将阻塞的业务从Dubbo内部线程池切换到业务自定义线程，避免Dubbo线程池的过度占用，有助于避免不同服务间的互相影响。异步执行无异于节省资源或提升RPC响应性能，因为如果业务执行需要阻塞，则始终还是要有线程来负责执行
juc.concurrent.CompletableFuture
CompletableFuture

# 泛化调用（客户端泛化）
特性说明: 泛化调用是指在调用方没有服务方提供的 API（SDK）的情况下，对服务方进行调用，并且可以正常拿到调用结果
泛化调用主要用于实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。比如如下场景：

网关服务：如果要搭建一个网关服务，那么服务网关要作为所有 RPC 服务的调用端。但是网关本身不应该依赖于服务提供方的接口 API（这样会导致每有一个新的服务发布，就需要修改网关的代码以及重新部署），所以需要泛化调用的支持。

测试平台：如果要搭建一个可以测试 RPC 调用的平台，用户输入分组名、接口、方法名等信息，就可以测试对应的 RPC 服务。那么由于同样的原因（即会导致每有一个新的服务发布，就需要修改网关的代码以及重新部署），所以平台本身不应该依赖于服务提供方的接口 API。所以需要泛化调用的支持

# RPC调用上下文
特性说明：上下文中存放的是当前调用过程中所需的环境信息。所有配置信息都将转换为 URL 的参数，参见 schema 配置参考手册 中的对应URL参数一列。

RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。












