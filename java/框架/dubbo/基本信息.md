响应时间：
并发数：同时处理的请求数量；
并发连接数：
请求数：
并发用户数：
吞吐量：
QPS：每秒请求数；
TPS:每秒事务数；
高性能：快速的访问体验；
高可用：服务一直可以正常访问；
可伸缩：
高可扩展：
安全性：
敏捷性： 
集群：
分布式：
单体架构：
垂直架构：多个单机的架构操作一个数据库，但业务不同，但是有重复的功能比如获取用户信息；
分布式系统：多个服务的消费者服务通过RPC远程调用服务的提供者服务，服务的提供方一旦发生变更，所有的消费方都需要变更；
SOA架构：SOA（Service-OrientedArchitecture），即面向服务的系统架构，是一个组件模型。SOA架构采用广为接受的标准把业务功能封装成标准化的服务，这类服务通过确定的且与最后实现没有关联的接口进行定义[1]。它是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义的接口进行通讯，不涉及底层编程接口和通讯模型，独立于实现服务的硬件平台、操作系统和编程语言。
ESB: 
微服务架构：主要作用是将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持；业务需要彻底的组件化和服务化，这些运行的小应用，是通过服务完成交互和集成。

# Dubbo
阿里巴巴开源的java RPC框架；
多版本：灰度发布；
超时机制，重试机制；
服务降级：


3.1.5	Dubbo3 最新稳定版本，建议所有的 3.x 用户都升级到该版本。

Dubbo 作为服务开发框架解决了业务应用中微服务定义、暴露、通信与治理的问题，为业务应用开发定义了一套微服务编程范式。 具体来说，Dubbo 为业务应用提供了微服务开发API、RPC 协议、服务治理三大核心能力，让开发者真正的专注业务逻辑开发。
Dubbo 不是应用框架的替代者，它可以很好的工作在每种语言的主流编程框架之上，以 Java 为例，Dubbo 可以很好的与 Spring 协作，并在此基础上提供服务定义、微服务编程、服务发现、负载均衡、流量管控等能力。
# 核心概念和架构
从抽象架构上分为两层：服务治理抽象控制面 和 Dubbo 数据面 。
服务治理控制面。服务治理控制面不是特指如注册中心类的单个具体组件，而是对 Dubbo 治理体系的抽象表达。控制面包含协调服务发现的注册中心、流量管控策略、Dubbo Admin 控制台等，如果采用了 Service Mesh 架构则还包含 Istio 等服务网格控制面。
Dubbo 数据面。数据面代表集群部署的所有 Dubbo 进程，进程之间通过 RPC 协议实现数据交换，Dubbo 定义了微服务应用开发与调用规范并负责完成数据传输的编解码工作。
服务消费者 (Dubbo Consumer)，发起业务调用或 RPC 通信的 Dubbo 进程
服务提供者 (Dubbo Provider)，接收业务调用或 RPC 通信的 Dubbo 进程
Dubbo 作为 服务开发框架 约束了微服务定义、开发与调用的规范，定义了服务治理流程及适配模式
Dubbo 作为 RPC 通信协议实现 解决服务间数据传输的编解码问题
Dubbo 从设计上不绑定任何一款特定通信协议，HTTP/2、REST、gRPC、JsonRPC、Thrift、Hessian2 等几乎所有主流的通信协议，Dubbo 框架都可以提供支持。
Dubbo 对通信协议的支持具有以下特点：

不绑定通信协议
提供高性能通信协议实现
支持流式通信模型
不绑定序列化协议
支持单个服务的多协议暴露
支持单端口多协议发布
支持一个应用内多个服务使用不同通信协议
# 服务治理
服务开发框架解决了开发与通信的问题，但在微服务集群环境下，我们仍需要解决无状态服务节点动态变化、外部化配置、日志跟踪、可观测性、流量管理、高可用性、数据一致性等一系列问题，我们将这些问题统称为服务治理。
# 服务治理功能定义
地址发现
负载均衡: Dubbo 默认提供加权随机、加权轮询、最少活跃请求数优先、最短响应时间优先、一致性哈希和自适应负载等策略
# 流量路由
Dubbo 支持通过一系列流量规则控制服务调用的流量分布与行为，基于这些规则可以实现基于权重的比例流量分发、灰度验证、金丝雀发布、按请求参数的路由、同区域优先、超时配置、重试、限流降级等能力。

# 链路追踪
Dubbo 官方通过适配 OpenTelemetry 提供了对 Tracing 全链路追踪支持，用户可以接入支持 OpenTelemetry 标准的产品如 Skywalking、Zipkin 等。另外，很多社区如 Skywalking、Zipkin 等在官方也提供了对 Dubbo 的适配。

# 可观测性
Dubbo 实例通过 Prometheus 等上报 QPS、RT、请求次数、成功率、异常次数等多维度的可观测指标帮助了解服务运行状态，通过接入 Grafana、Admin 控制台帮助实现数据指标可视化展示。

spring应用框架-》 spring boot微服务框架 -〉 spring cloud服务治理
dubbo服务开发&治理
Dubbo 和 Spring Cloud 都侧重在对分布式系统中常见问题模式的抽象（如服务发现、负载均衡、动态配置等），同时对每一个问题都提供了配套组件实现，形成了一套微服务整体解决方案，让使用 Dubbo 及 Spring Cloud 的用户在开发微服务应用时可以专注在业务逻辑开发上。
Spring Cloud 的优势在于：

同样都支持 Spring 开发体系的情况下，Spring Cloud 得到更多的原生支持
对一些常用的微服务模式做了抽象如服务发现、动态配置、异步消息等，同时包括一些批处理任务、定时任务、持久化数据访问等领域也有涉猎。
基于 HTTP 的通信模式，加上相对比较完善的入门文档和演示 demo 和 starters，让开发者在第一感觉上更易于上手
Spring Cloud 的问题有：
只提供抽象模式的定义不提供官方稳定实现，开发者只能寻求类似 Netflix、Alibaba、Azure 等不同厂商的实现套件，而每个厂商支持的完善度、稳定性、活跃度各异
有微服务全家桶却不是能拿来就用的全家桶，demo 上手容易，但落地推广与长期使用的成本非常高
欠缺服务治理能力，尤其是流量管控方面如负载均衡、流量路由方便能力都比较弱
编程模型与通信协议绑定 HTTP，在性能、与其他 RPC 体系互通上存在障碍
总体架构与实现只适用于小规模微服务集群实践，当集群规模增长后就会遇到地址推送效率、内存占用等各种瓶颈的问题，但此时迁移到其他体系却很难实现
很多微服务实践场景的问题需要用户独自解决，比如优雅停机、启动预热、服务测试，再比如双注册、双订阅、延迟注册、服务按分组隔离、集群容错等
都是 Dubbo 的优势所在：

完全支持 Spring & Spring Boot 开发模式，同时在服务发现、动态配置等基础模式上提供与 Spring Cloud 对等的能力。
是企业级微服务实践方案的整体输出，Dubbo 考虑到了企业微服务实践中会遇到的各种问题如优雅上下线、多注册中心、流量管理等，因此其在生产环境的长期维护成本更低
在通信协议和编码上选择更灵活，包括 rpc 通信层协议如 HTTP、HTTP/2(Triple、gRPC)、TCP 二进制协议、rest等，序列化编码协议Protobuf、JSON、Hessian2 等，支持单端口多协议。
Dubbo 从设计上突出服务服务治理能力，如权重动态调整、标签路由、条件路由等，支持 Proxyless 等多种模式接入 Service Mesh 体系
高性能的 RPC 协议编码与实现，
Dubbo 是在超大规模微服务集群实践场景下开发的框架，可以做到百万实例规模的集群水平扩容，应对集群增长带来的各种问题
`Dubbo 提供 Java 外的多语言实现，使得构建多语言异构的微服务体系成为可能`
# Dubbo 与 gRPC 最大的差异在于两者的定位上：
gRPC 定位为一款 RPC 框架，Google 推出它的核心目标是定义云原生时代的 rpc 通信规范与标准实现;
Dubbo 定位是一款微服务开发框架，它侧重解决微服务实践从服务定义、开发、通信到治理的问题，因此 Dubbo 同时提供了 RPC 通信、与应用开发框架的适配、服务治理等能力。
Dubbo 不绑定特定的通信协议，即 Dubbo 服务间可通过多种 RPC 协议通信并支持灵活切换。因此，你可以在 Dubbo 开发的微服务中选用 gRPC 通信，Dubbo 完全兼容 gRPC，并将 gRPC 设计为内置原生支持的协议之一。
gRPC 更适合作为底层的通信协议规范或编解码包，Dubbo 则可用作微服务整体解决方案;\
# 构建可伸缩的微服务集群
流量管控
在地址发现和负载均衡机制之外，Dubbo 丰富的流量管控规则可以控制服务间的流量走向和 API 调用，基于这些规则可以实现在运行期动态的调整服务行为如超时时间、重试次数、限流参数等，通过控制流量分布可以实现 A/B 测试、金丝雀发布、多版本按比例流量分配、条件匹配路由、黑白名单等，提高系统稳定性。
动态调整超时时间
服务重试
访问日志
同区域优先
灰度环境隔离
参数路由
按权重比例分流
金丝雀发布
服务降级
实例临时拉黑
指定机器导流
# 服务网格
基于 Dubbo 开发的服务可以透明的接入 Istio 等服务网格体系，Dubbo 支持基于 Envoy 的流量拦截方式，也支持更加轻量的 Proxyless Mesh 部署模式。

# service 与 reference
service 与 reference 是 Dubbo 最基础的两个配置项，它们用来将某个指定的接口或实现类注册为 Dubbo 服务，并通过配置项控制服务的行为。

service 用于服务提供者端，通过 service 配置的接口和实现类将被定义为标准的 Dubbo 服务，从而实现对外提供 RPC 请求服务。
reference 用于服务消费者端，通过 reference 配置的接口将被定义为标准的 Dubbo 服务，生成的 proxy 可发起对远端的 RPC 请求。
# consumer 与 provider
当应用内有多个 reference 配置时，consumer 指定了这些 reference 共享的默认值，如共享的超时时间等以简化繁琐的配置，如某个 reference 中单独设置了配置项值则该 reference 中的配置优先级更高。
当应用内有多个 service 配置时，provider 指定了这些 service 共享的默认值，如某个 service 中单独设置了配置项值则该 service 中的配置优先级更高。
consumer 组件还可以对 reference 进行虚拟分组，不通分组下的 reference 可有不同的 consumer 默认值设定；如在 XML 格式配置中，<dubbo:reference /> 标签可通过嵌套在 <dubbo:consumer /> 标签之中实现分组。provider 与 service 之间也可以实现相同的效果。

注解有 @DubboService、@DubboReference 与 EnableDubbo。其中 @DubboService 与 @DubboReference 用于标记 Dubbo 服务，EnableDubbo 启动 Dubbo 相关配置并指定 Spring Boot 扫描包路径。
配置文件 application.properties 或 application.yml

# 启动时检查
Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 check="true"。
可以通过 check="false" 关闭检查，比如，测试时，有些服务不关心，或者出现了循环依赖，必须有一方先启动。
另外，如果你的 Spring 容器是懒加载的，或者通过 API 编程延迟引用服务，请关闭 check，否则服务临时不可用时，会抛出异常，拿到 null 引用，如果 check="false"，总是会返回引用，当服务恢复时，能自动连上。
## 使用场景
单向依赖：有依赖关系（建议默认设置）和无依赖关系（可以设置 check=false）
相互依赖：即循环依赖，(不建议设置 check=false)
延迟加载处理
`check 只用来启动时检查，运行时没有相应的依赖仍然会报错`
# 响应式编程
基于 Triple 协议和 Project Reactor 实现，3.1.0 版本以上支持用户仅需编写 IDL 文件，并指定 protobuf 插件的相应 Generator，即可生成并使用支持响应式API的 Stub 代码。
有四种调用模式，分别是 OneToOne、OneToMany、ManyToOne、ManyToMany，分别对应 Unary调用、服务端流、客户端流、双向流。在 Reactor 的实现中，One 对应 Mono，Many 对应 Flux。
Reactive Stream 提供了一套标准的异步流处理 API， 在能够让应用写出事件驱动的程序的同时，也通过 BackPressure 的方式保证了节点的稳定。Triple 协议在通信协议层面为 Dubbo 框架增加了流式场景的支持，在此基础上能够实现上层包括大文件传输和推送机制的业务需求。Dubbo + Reactive Stream Stub 的组合模式可以给用户带来最方便的流式使用方式以及全链路异步性能提升
## 使用场景
系统需要处理大量并发请求而不会使任何服务器过载。大量用户提供实时数据的系统，希望确保系统能够处理负载而不会崩溃或变慢。
# 参数校验
参数验证功能是基于 JSR303 实现的，用户只需标识 JSR303 标准的验证 annotation，并通过声明 filter 来实现验证

# 服务分组
同一个接口针对不同的业务场景、不同的使用需求或者不同的功能模块等场景，可使用服务分组来区分不同的实现方式。同时，这些不同实现所提供的服务是可并存的，也支持互相调用。
使用场景
当一个接口有多种实现时，可以用 group 区分。一个接口，分组实现，消费一个接口分组调用；
# 集群容错
在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。
各节点关系：
这里的 Invoker 是 Provider 的一个可调用 Service 的抽象，Invoker 封装了 Provider 地址及 Service 接口信息
Directory 代表多个 Invoker，可以把它看成 List<Invoker> ，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更
Cluster 将 Directory 中的多个 Invoker 伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个
Router 负责从多个 Invoker 中按路由规则选出子集，比如读写分离，应用隔离等
LoadBalance 负责从多个 Invoker 中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选
通过使用服务注册表和负载平衡，可以提高集群提供的容错能力，服务注册表用于存储有关可用服务及其位置的信息，负载平衡用于确保请求均匀分布在集群中的所有服务器上，如果一台服务器发生故障，负载将转移到其他可用服务器。
配置监视集群中服务器运行状况的运行状况检查，如果服务器未通过运行状况检查，则可以将其从集群中删除，并将负载转移到其余服务器，确保集群正常运行，并且用户可以使用应用程序。
使用场景
多个服务器部署同一集群中，运行同一应用程序，如果一台服务器出现故障，其他服务器将接管负载，确保应用程序对用户仍然可用
可以自行扩展集群容错策略 集群扩展
## 在服务提供方和消费方配置集群模式
<dubbo:service cluster="failsafe" />
<dubbo:reference cluster="failsafe" />
Failfast Cluster: 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
Failsafe Cluster: 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
Failback Cluster: 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
Forking Cluster: 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。
Broadcast Cluster: 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。
# 服务降级(避免雪崩)
服务降级是指服务在非正常情况下进行降级应急处理。
使用场景
某服务或接口负荷超出最大承载能力范围，需要进行降级应急处理，避免系统崩溃
调用的某非关键服务或接口暂时不可用时，返回模拟数据或空，业务还能继续可用
降级非核心业务的服务或接口，腾出系统资源，尽量保证核心业务的正常运行
某上游基础服务超时或不可用时，执行能快速响应的降级预案，避免服务整体雪崩






# 分组聚合
通过分组对结果进行聚合并返回聚合后的结果，比如菜单服务，用 group 区分同一接口的多种实现，现在消费方需从每种 group 中调用一次并返回结果，对结果进行合并之后返回，这样就可以实现聚合菜单项。

# 服务分版本
在低压力时间段，先升级一半提供者为新版本
再将所有消费者升级为新版本
然后将剩下的一半提供者升级为新版本
配置 
新老版本服务提供者
新老版本服务消费者
使用场景: 当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。

# 权限控制
通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者， 可以防止消费者绕过注册中心访问提供者， 另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者。

在一定程度上实现客户端和服务端的可信鉴权，避免任意客户端都可以访问，降低出现安全问题的风险。
<!--固定token令牌，相当于密码-->
<dubbo:provider token="123456" />
<!--随机token令牌，使用UUID生成-->
<dubbo:provider token="true" />
<!--随机token令牌，使用UUID生成-->
<dubbo:service interface="com.foo.BarService" token="true" />
<!--固定token令牌，相当于密码-->
<dubbo:service interface="com.foo.BarService" token="123456" />

# 主机地址自定义暴露
使用场景
应用程序包含多个服务每个服务定制地址，外部客户端通过定制的地址访问服务。
应用程序同一服务的多个版本每个版本的服务定制地址，外部客户端通过定制的地址访问相应版本的服务。
应用程序多个地区部署服务每个地区定制地址，外部客户端通过定制的地址访问相应地区的相应服务。
可以通过dubbo.protocol或dubbo.provider的host属性对host进行配置,支持IP地址和域名.但此时注册到注册中心的IP地址和监听IP地址是同一个值
为了解决在虚拟环境或局域网内consumer无法与provider通信的问题,可以通过环境变量分别设置注册到注册中心的IP地址和监听IP地址,其优先级高于dubbo.protocol或dubbo.provider的host配置

environment:
- "DUBBO_IP_TO_REGISTRY=192.168.1.3" 注册到注册中心的 ip 地址
- "DUBBO_PORT_TO_REGISTRY=20887" 注册到注册中心的 port 端口
- "DUBBO_IP_TO_BIND=192.168.1.3" 监听 ip 地址
- "DUBBO_PORT_TO_BIND=8088" 监听 port 端口

# 优雅停机

# 延迟暴露
如果你的服务需要预热时间，比如初始化缓存，等待相关资源就位等，可以使用 delay 进行延迟暴露。我们在 Dubbo 2.6.5 版本中对服务延迟暴露逻辑进行了细微的调整，将需要延迟暴露（delay > 0）服务的倒计时动作推迟到了 Spring 初始化完成后进行。你在使用 Dubbo 的过程中，并不会感知到此变化，因此请放心使用。

当服务完全配置并准备好向外界暴露时才会触发服务的暴露，保证服务在准备就绪时暴露，提高了服务系统可靠性。

强烈建议不要在服务的实现类中有 applicationContext.getBean() 的调用，全部采用 IoC 注入的方式使用 Spring的Bean。
如果实在要调 getBean()，可以将 Dubbo 的配置放在 Spring 的最后加载。
如果不想依赖配置顺序，可以使用 <dubbo:provider delay=”-1” />，使 Dubbo 在 Spring 容器初始化完后，再暴露服务。
如果大量使用 getBean()，相当于已经把 Spring 退化为工厂模式在用，可以将 Dubbo 的服务隔离单独的 Spring 容器。

# 异步调用
Dubbo 的所有异步编程接口开始以 CompletableFuture 为基础
基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小。
使用场景
将用户请求内容发送到目标请求，当目标请求遇到高流量或需要长时间处理，异步调用功能将允许立即向用户返回响应，同时目标请求继续后台处理请求，当目标请求返回结果时，将内容显示给用户。
使用方式
使用 CompletableFuture 签名的接口
需要服务提供者事先定义 CompletableFuture 签名的服务，接口定义指南如下：

Provider端异步执行将阻塞的业务从Dubbo内部线程池切换到业务自定义线程，避免Dubbo线程池的过度占用，有助于避免不同服务间的互相影响。异步执行无异于节省资源或提升RPC响应性能，因为如果业务执行需要阻塞，则始终还是要有线程来负责执行
juc.concurrent.CompletableFuture
CompletableFuture

# 泛化调用（客户端泛化）
特性说明: 泛化调用是指在调用方没有服务方提供的 API（SDK）的情况下，对服务方进行调用，并且可以正常拿到调用结果
泛化调用主要用于实现一个通用的远程服务 Mock 框架，可通过实现 GenericService 接口处理所有服务请求。比如如下场景：

网关服务：如果要搭建一个网关服务，那么服务网关要作为所有 RPC 服务的调用端。但是网关本身不应该依赖于服务提供方的接口 API（这样会导致每有一个新的服务发布，就需要修改网关的代码以及重新部署），所以需要泛化调用的支持。

测试平台：如果要搭建一个可以测试 RPC 调用的平台，用户输入分组名、接口、方法名等信息，就可以测试对应的 RPC 服务。那么由于同样的原因（即会导致每有一个新的服务发布，就需要修改网关的代码以及重新部署），所以平台本身不应该依赖于服务提供方的接口 API。所以需要泛化调用的支持

# RPC调用上下文
特性说明：上下文中存放的是当前调用过程中所需的环境信息。所有配置信息都将转换为 URL 的参数，参见 schema 配置参考手册 中的对应URL参数一列。

RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。












