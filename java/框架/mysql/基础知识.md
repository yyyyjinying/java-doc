
`between`的用法，between限制查询数据范围时包括了边界值，not between不包括：

# 根据已有的表创建新表：
create table tab_new like tab_old;(使用旧表B创建新表A)  (MySQL)
备注：此种方式在将表B复制到A时候会将表B完整的字段结构和索引复制到表A中来。但不会复制数据。
create table tab_new as select col1,col2... from tab_old definition only;        
备注：此种方式只会将B表的字段结构复制到表A中来，但不会复制表B中的索引到表A中来。这种方式比较灵活可以在复制原来表结构的同时指定要复制哪些字段，并且自身复制表也可以
根据需要增加字段结构。
pro
查询锁：select from dba_blockers;
查询被阻塞的会话：select from dba_waiters;
显示两个表内的相同数据：select column_name from tab_old intersect select column_name from tab_new;
SQL语句中过滤条件where和having的区别：
where是一个约束声明，使用where约束来自数据库的数据，where是在结果返回之前起作用，where中不能使用聚合函数。
Having是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数。
在查询过程中聚合语句（sum，min，max，avg，count）要比having子句优先执行。而where子句在查询过程中执行优先级高于聚合语句。
# 数据库
数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。在mysql中可以创建多个数据库，一个数据库可以管理很多张表。
```mysql
CREATE DATABASE 数据库名;
SHOW DATABASES;
USE 数据库名;
```
# 表
TABLE）是数据库中用来存储数据的对象，是有结构的数据的集合，是整个数据库系统的基础。
# SQL
SQL是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。
# SQL语句分类
DCL(Data Control Language)：数据控制语言，用来定义`访问权限和安全级别`。
DDL(Data Definition Language)：数据定义语言，用来定义数据库对象：库、表、列等。功能：创建、删除、修改`库和表结构`。
DML(Data Manipulation Language)：数据操作语言，用来定义数据库记录：增、删、改`表记录`。
DQL(Data Query Language)：数据查询语言，用来`查询记录`。
# DDL(数据定义语言)语法
`常用的数据类型`:tinyint,smallint,mediumint,int,bigint
unsigned关键字:默认有符号,定义成无符号;比如：tinyint unsigned的取值范围为0~255，
`浮点型`:float(m, d),4字节，单精度浮点型，m总长度，d小数位;
double(m, d)双精度浮点型;decimal(m, d)存储为字符串的浮点数;对应我们java的Bigdecimal
字符串数据类型:char(n),varchar(n),tinytext,text,mediumtext(16MB),longtext(4GB),
当存储char值时，char会截取超出的字符,MySQL是自动删除输入字符串末尾的空格;varchar(n)类型用于存储【可变长】的，长度最大为n个字符的可变长度字符数据。char类型每次修改的数据长度相同，效率更高，varchar类型每次修改的数据长度不同，效率更低。实质上存储和 text 差别不是太大了。因为超长的 varchar 也是会用到溢出存储，读取该行也是要去读硬盘然后加载到内存，基本认为是一样的。如果存储的数据大于64K，就必须使用到 mediumtext，longtext，因为 varchar 已经存不下了,如果 varchar(255+) 之后，和 text 在存储机制是一样的，性能也相差无几。
`日期和时间数据类型`:date3字节，日期，格式：2014-09-18, time:3字节，时间，格式：08:42:30;datetime:8字节，日期时间，格式：2014-09-18 08:42:30;timestamp:4字节，自动存储记录修改的时间;year	1字节，年份
## MySQL约束类型
NOT NULL:非空约束,UNIQUE:唯一约束，取值不允许重复,PRIMARY KEY:主键约束（主关键字），自带非空、唯一、索引;DEFAULT:自动添加默认值（缺省值）;FOREIGN KEY:外键约束（外关键字）;AUTO_INCREMENT约束（递增的主键）
主键分为单字段主键和多字段联合主键：
- 每个表只能定义一个主键。
- 主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在有相同主键值的两行数据。这是唯一性原则
- 一个字段名只能在联合主键字段表中出现一次
- 【联合主键】不能包含不必要的多余字段。当把联合主键的某一字段删除后，如果剩下的字段构成的主键仍然满足唯一性原则，那么这个联合主键是不正确的。这是最小化原则
FOREIGN KEY约束：
- 删除表时，如果不删除引用外键的表，被引用的表不能直接删除；
- 外键的值必须来源于引用的表的主键字段
语法：foreign key (aut_id) references author(aut_id)；FOREIGN KEY [column list] REFERENCES [primary key table] ([column list]);
```mysql
查看表结构:DESC 表名;
# 添加列
alter table author add (hobby varchar(20),address varchar(50));
# 改列类型
alter table author modify address varchar(100);
# 名称和列类型一起修改
alter table author change address addr varchar(60);
# 删除列
alter table author drop addr;
# 修改表名
alter table author rename authors;
# 删除表：
drop table if exists 表名;
``
# DML(数据操作语言)语法
```mysql
# 插入数据
insert into `authors` (aut_name,gander,country,brithday,hobby) values ('罗曼罗兰','女','漂亮国','1969-1-14','旅游');
# 批量插入：
insert into `authors` (aut_name,gander,country,brithday,hobby) values ('罗曼罗兰','女','漂亮国','1969-1-14','旅游'),('海明威','男','老人与海','1969-1-3','看书');
# 修改某列的全部值
update `authors` set aut_name = '吴军',country='中国';
# 修改某列的指定的值
UPDATE author set aut_name='lucy' where aut_id = 1;
# 删除数据
delete from 表名 (where 条件);
```
`逻辑运算符`如下：=、!=、<>、<、>、>=、<=、between...and、in(…)、is null、not、or、and，其中in(...)的用法表示集合
- where aut_id >1
- where aut_id in (1,3,5)
- where aut_id between 1 and 4
- where aut_id >1 and aut_name='xxx'
- where aut_name is null
- where aut_name is not null
## truncate
表和索引的所占空间会恢复到初始大小
truncate和delete只删除数据，drop则删除整个表（结构和数据）。
truncate速度快，效率高，可以理解为先把表删除了，再重新建立。
truncate和delete均不会使表结构及其列、约束、索引等发生改变。
# DQL数据查询语言
## 单表查询
```mysql
select * from 表名;
select `id`,`name`,`age` from `student`;
# 完全重复的记录只显示一次，在查询的列之前添加`distinct`
# 列运算:
# 数量类型的列可以做加、减、乘、除等运算
select id,name,sal+1000 from employee；
# 别名
select `id` `编号`,`name` `名字`,ifnull(`age`,0) as `age` from `student` as s;
# 条件控制
select * from student where id in (1,3,7);
# 模糊查询:关键字like
select * from student where name like '张%';
# （_代表匹配任意一个字符，％代表匹配0～n个任意字符）
# 排序(所谓升序和降序都是从上往下排列)
## 升序: ascend
select * form 表名 order by 列名 asc;     # asc为默认值可以不写
## 降序:descend
select * from 表名 order by 列名 desc;
# 多列作为排序条件
select * from 表名 order by 列名1 asc, 列名2 desc;

```
null加任何值都等于null，，需要用到ifnull()函数。SELECT IFNULL(sal,0) from 表名; 如果薪资列为空，则输出0；
将字符串做加减乘除运算，会把字符串当作0。
使用多列作为排序条件： 当第一列排序条件相同时，根据第二列排序条件排序(当第二列依旧相同时可视情况根据第三例条件排序)：
### 聚合函数
count：查询满足条件的记录行数，后边可以跟where条件：
max：查询满足条件的记录中的最大值，后边可以跟where条件：
min：查询满足条件的记录中的最大值，后边可以跟where条件：
sum：查询满足条件的记录中的值的和，后边可以跟where条件：
avg：查询满足条件的记录中的值的平均数，后边可以跟where条件：
### 分组查询
分组查询前
select 分组列，聚合函数 from 表名 where 条件 group by 分组列;
分组查询后
select 分组列，聚合函数 from 表名 where 条件 group by 分组列 having 聚合函数或列名(条件)；
```mysql
select gander,avg(age) avg_age,sum(age) sum_age from student GROUP BY gander HAVING  gander = '男'
```
### LIMIT子句
说明从开始查找三条记录
select * from 表名 limit 3;
如果两个参数：说明从第三行起（不算），向后查三条记录
SELECT id,name,age,gander FROM student limit 3,3;
# 多表查询
## 笛卡尔积
如果是两张无关的表联合查询，列出所有的可能的结果
查询的过程大致如下：
1、选取一张表，我们称之为【驱动表】，从驱动表中开始查询，找到满足条件的数据（如果没有条件就依次全部取出）。
2、根据从驱动表查询的这条数据，以及其他条件，去第二张【被驱动表】中查询，并将结果进行拼接。
3、依次类推，从驱动表获取第二条数据，使用该数据和条件，再次查询【被驱动表】进行查询。
4、整个过程，会查询【驱动表】一次，查询【被驱动表】多次。
### 关联查询
对于没有【条件约束】的两张表进行关联查询，如select * from t1,t2，就是从t1中一条条的选取数据，然后全量匹配t2的所有数据，形成一个大的集合，集合的数据量是两表数据量的乘积，我们称之为笛卡尔积；
### 多表连接的方式有四种
内连接、外链接（左外连接，右外连接），全连接
# 内连接(表 A 和 表 B 的数据的交集)
使用逗号分割两张表进行查询（employee e,dept e），mysql经过优化默认就等效与内链接，内连接使用关键字 【inner join】 或 【join】 来连接两张表。内连接中，【驱动表】是系统优化后自动选取的，会将执行计划中【扫描次数少】的表选做【驱动表】。三条sql等效
```mysql
SELECT * from teacher t ,course c where c.t_id = t.id
SELECT * from teacher t join course c on c.t_id = t.id
SELECT * from teacher t inner join course c on c.t_id = t.id
```
# 外连接
内连接和外连接的区别:
对于【内连接】中的两个表，若【驱动表】中的记录在【被驱动表】中找不到与之匹配的记录，则该记录不会被加入到最后的结果集中。
对于【外连接】中的两个表，即使【驱动表】中的记录在【被驱动表】中找不到与之匹配的记录，也要将该记录加入到最后的结果集中，针对不同的【驱动表的选择】，又可以将外连接分为【左外连接】和【右外连接】。
- 对于左外连接查询的结果会包含左表的所有数据,将不能匹配其他表的字段都置空 【Null】
- 对于左外连接查询的结果会包含左表的所有数据,将不能匹配其他表的字段都置空 【Null】
## 左连接（左外连接）
```mysql
SELECT * from course c left outer join on teacher t c.t_id = t.id
SELECT * from course c left join on teacher t c.t_id = t.id
```
# 全连接
`mysql中并不支持全连接`，但是有些数据库是支持的，比如`oracle`，使用【full outer join】关键字
```mysql
# mysql的全连接
SELECT * from teacher t right outer join course c on c.t_id = t.id
union
SELECT * from teacher t left outer join course c on c.t_id = t.id
```
### 子查询
- 标量子查询：结果集只有一行一列 （又称为单行子查询）
```mysql
# 查询比连宇栋年龄大的所有的学生 (标量子查询)
select * from student where age > (
	select age from student where name = '连宇栋'
);
```
- 列子查询： 结果集只有一列多行
```mysql
查询有一门学科分数大于九十分的学生信息 (列子查询)
select * from student where id in(
	select distinct s_id from scores where score > 90
)
```
- 行子查询： 结果集只有一行多列
```mysql
-- 查询男生且是年龄最大学的学生信息
select * from student 
where gander = '男' and age = (
	select max(age) from student  
	GROUP BY gander having gander = '男'
)

select * from student 
where (gander,age) = (
	select gander,max(age) from student  
	GROUP BY gander having gander = '男'
)
```
# 总结
where 型子查询，如果是 where 列 =（内层 sql） 则内层 sql 返回的必须是单行单列，单个值。
where 型子查询，如果是 where 列 in（内层 sql） 则内层 sql 返回的必须是单列，可以多行。

- 表子查询(from子查询)： 结果集一般为多行多列
查询结果集在结构上可以当成表看，那就可以当成临时表对他进行再次查询，所以他支持的就是表子查询；
```mysql
取排名数学成绩前五名的学生，正序排列。
select * from (
select s.id,s.name sname,r.score,c.name cname from student s 
left join scores r on s.id = r.s_id  
left join course c on r.c_id = c.id 
where c.name = '数学' 
order by  r.score desc
limit 5) t order by  t.score 
```
- SELECT型子查询
在select关键字后的子查询仅仅支持标量子查询。
```mysql
select t.id,t.name,(
	select count(*) from course c where c.t_id = t.id
) as `代课的数量` 
from teacher t;
```
- exists型子查询
```mysql
select * from teacher t where exists (
	select * from course c where c.t_id = t.id
);
```
# MySQL常用函数
## 聚合函数
是平时比较常用的一类函数，这里列举如下：
COUNT(col) ： 统计查询结果的行数
MIN(col)： 查询指定列的最小值
MAX(col)： 查询指定列的最大值
SUM(col)： 求和，返回指定列的总和
AVG(col)： 求平均值，返回指定列数据的平均值
## 数值型函数
CEILING(x)： 返回大于x的最小整数值，向上取整
FLOOR(x)： 返回小于x的最大整数值，向下取整
ROUND(x,y)： 返回参数x的四舍五入的有y位小数的值 四舍五入
TRUNCATE(x,y)： 返回数字x截短为y位小数的结果
PI()： 返回pi的值（圆周率）
RAND()： 返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值
```mysql
# ABS()函数求绝对值
SELECT ABS(5),ABS(-2.4),ABS(-24),ABS(0);

# 取整函数 CEIL(x) 和 CEILING(x) 的意义相同，返回不小于 x 的最小整数值
SELECT CEIL(-2.5),CEILING(2.5);

# 求余函数 MOD(x,y) 返回 x 被 y 除后的余数
SELECT MOD(63,8),MOD(120,10),MOD(15.5,3);

# RAND() 函数被调用时，可以产生一个在 0 和 1 之间的随机数
SELECT RAND(), RAND(), RAND();
```
## 字符串函数
LENGTH(s)： 计算字符串长度函数，返回字符串的字节长度
CONCAT(s1,s2...,sn)： 合并字符串函数，返回结果为连接参数产生的字符串，参数可以是一个或多个
LOWER(str)： 将字符串中的字母转换为小写
UPPER(str)： 将字符串中的字母转换为大写
LEFT(str,x)： 返回字符串str中最左边的x个字符
RIGHT(str,x)： 返回字符串str中最右边的x个字符
TRIM(str)： 删除字符串左右两侧的空格
REPLACE： 字符串替换函数，返回替换后的新字符串 REPLACE(name,'白','黑')
SUBSTRING： 截取字符串，返回从指定位置开始的指定长度的字符换
REVERSE(str)： 返回颠倒字符串str的结果
```mysql
# LENGTH(str) 函数的返回值为字符串的字节长度
SELECT LENGTH('name'),LENGTH('数据库');
# CONCAT(sl，s2，...) 函数返回结果为连接参数产生的字符串 若有任何一个参数为 NULL，则返回值为 NULL
SELECT CONCAT('MySQL','5.7'),CONCAT('MySQL',NULL);
# INSERT(s1，x，len，s2) 返回字符串 s1，子字符串起始于 x 位置，并且用 len 个字符长的字符串代替 s2
SELECT INSERT('Football',2,4,'Play') AS col1,INSERT('Football',-1,4,'Play') AS col2;
# UPPER,LOWER是大小写转换函数
SELECT LOWER('BLUE'),LOWER('Blue'),UPPER('green'),UPPER('Green');
# LEFT,RIGHT是截取左边或右边字符串函数
SELECT LEFT('MySQL',2),RIGHT('MySQL',3);
# REPLACE(s，s1，s2) 使用字符串 s2 替换字符串 s 中所有的字符串 s1
SELECT REPLACE('aaa.mysql.com','a','w');
# 函数 SUBSTRING(s，n，len) 带有 len 参数的格式，从字符串 s 返回一个长度同 len 字符相同的子字符串，起始于位置 n
SELECT SUBSTRING('computer',3) AS col1,SUBSTRING('computer',3,4) AS col2,
SUBSTRING('computer',-3) AS col3,SUBSTRING('computer',-5,3) AS col4;
```
## 日期和时间函数
获取时间和日期
- 【CURDATE】 和 CURRENT_DATE】 两个函数作用相同，返回当前系统的日期值
- 【CURTIME 和 CURRENT_TIME】 两个函数作用相同，返回当前系统的时间值
- 【NOW】 和 【SYSDATE】 两个函数作用相同，返回当前系统的日期和时间值
  
## 时间戳或日期转换函数：
【UNIX_TIMESTAMP】 获取UNIX时间戳函数，返回一个以 UNIX 时间戳为基础的无符号整数
【FROM_UNIXTIME】 将 UNIX 时间戳转换为时间格式，与UNIX_TIMESTAMP互为反函数
## 根据日期获取年月日的数值
【MONTH】 获取指定日期中的月份
【MONTHNAME】 获取指定日期中的月份英文名称
【DAYNAME】 获取指定曰期对应的星期几的英文名称
【DAYOFWEEK】 获取指定日期对应的一周的索引位置值
【WEEK】 获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53
【DAYOFYEAR】 获取指定曰期是一年中的第几天，返回值范围是1~366
【DAYOFMONTH】 获取指定日期是一个月中是第几天，返回值范围是1~31
【YEAR】 获取年份，返回值范围是 1970〜2069
## 时间日期的计算
【DATE_ADD】 和 【ADDDATE】 两个函数功能相同，都是向日期添加指定的时间间隔
【DATE_SUB】 和【 SUBDATE】 两个函数功能相同，都是向日期减去指定的时间间隔
【ADDTIME】 时间加法运算，在原始时间上添加指定的时间
【SUBTIME】 时间减法运算，在原始时间上减去指定的时间
【DATEDIFF】 获取两个日期之间间隔，返回参数 1 减去参数 2 的值
【DATE_FORMAT】 格式化指定的日期，根据参数返回指定格式的值
## 加密函数
SELECT MD5('abc');
结果：900150983cd24fb0d6963f7d28e17f72
## 流程控制函数
IF(test,t,f)： 如果test是真，返回t；否则返回f
IFNULL(arg1,arg2)： 如果arg1不是空，返回arg1，否则返回arg2
NULLIF(arg1,arg2)： 如果【arg1=arg2】返回NULL，否则返回arg1

# 数据库设计共三个规范：
第一范式：要求有主键，并且要求每一个字段原子性不可再分
第二范式：要求所有非主键字段完全依赖主键，不能产生部分依赖
第三范式：所有非主键字段和主键字段之间不能产生传递依赖（专业名称依赖于专业编号不是学生编号）
主键：主要采用数值型或定长字符串表示，关于列不可再分，应该根据具体的情况来决定；
一对一 用的不多:合并为一张表
一对多:外键建在多的一方
多对多:分三张表存储，在学生表中存储学生信息，在课程表中存储课程信息，
在成绩表中存储学生和课程的关系信息