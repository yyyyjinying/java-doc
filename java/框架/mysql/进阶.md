# mysql的系统架构
数据库：按照数据结构来组织、存储和管理数据的仓库，通常由数据库管理系统进行管理。
数据库管理软件（RDBMS）：就是我们说的数据库管理系统软件，他强调软件。
数据库实例：启动数据库软件，在内存中运行一个独立进程，用来操作数据，这个正在运行的进程就是一个数据库实例，理论上可以在一台电脑上启动多个数据库实例，当然要监听在不同的端口。
# MySQL 体系结构
连接层
最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。
服务层
第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。
引擎层
存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。
存储层
数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。
将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

# 查询当前数据库支持的存储引擎
SHOW ENGINES;
# InnoDB
是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。
特点
DML操作遵循ACID模型，支持事务；
行级锁，提高并发访问性能；
支持外键FOREIGN KEY约束，保证数据的完整性和正确性；

文件
xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。

# MyISAM是MySQL早期的默认存储引擎。
特点
不支持事务，不支持外键
支持表锁，不支持行锁
访问速度快
文件
xxx.sdi：存储表结构信息
xxx.MYD: 存储数据
xxx.MYI: 存储索引
# Memory
Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。
特点
内存存放
hash索引（默认）
文件
xxx.sdi：存储表结构信息


# MySQL架构
# I/O和存储
sql的成本主要:
I/O成本：我们经常使用的MyIsam和InnoDB存储引擎都是将数据存储在磁盘上，当查询表中的记录时，需要先将数据加载到内存中，然后进行操作，这个从磁盘到内存的加载过程损耗的时间成为I/O成本。
CPU成本：读取记录以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作所消耗的时间称之为CPU成本。
读写一次磁盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高磁盘传输效率，软件程序应着重考虑减少寻道时间和延迟时间。
# 数据存储
对于mysql而言，数据是存储在文件系统中的，不同的存储引擎会有不同的文件格式和组织形式
innodb数据存储
对于innodb而言，数据是存储在表空间（文件空间file space）内的，表空间是一个抽象的概念
表空间存储数据的单位是【页】，我们可以这样类比，一个表空间就是个大大的本子，本子里是一页页的数据（innodb是以页为单位进行数据存储的），常用页面类型有很多，不同类型的页面可以存放【不同类型的数据】，这里不展开讲解，暂时统称为【数据页】、他的通用部分如下，每一页大概占用16k的空间：
file header：记录页面的一些通用信息，比如当前页的校验和、页号、上页号、下页号、所属表空间等。
file trailer：主要的工作是检验页是否完整。
表空间中的每一个页，都有一个页号（File_PAGE_OFFSET），我们可以通过这个页号在表空间快速定位到指定的页面。这个页号由4个字节组成，也就是32位，所有最多能存放2的32次方页，如果按照一页16k计算，一个表空间最大支持【64TB】的数据。整体的排列中页是连续的，但是页有上下指针，不连续的页也能组成链表。
表空间可以分为系统表空间、独立表空间等：

# 缓冲池 buffer pool
innodb中的数据是以【页】的形式存储在磁盘上的表空间内，
磁盘的速度 内存的速度 cpu的速度
由缓冲页和控制块组成:
buffer pool中存放的【数据页】我们称之为【缓冲页】，和磁盘上的数据页是一一对应的，都是16KB，缓冲页的数据，是从磁盘上加载到buffer pool当中的一个完整页。
控制块:(描述信息)这一块区域保存的是数据页所属的表空间号，数据页编号，数据页地址，以及一些链表相关的节点信息等，每个控制块大小是缓存页的5%左右
数据库会在启动的时候，按照配置中的Buffer Pool大小，去向操作系统申请一块内存，作为Buffer Pool的内存区域，然后会按照默认的缓存页的的大小【16KB】以及对应的【800个字节左右】的【控制块】的大小，在Buffer Pool中划分出一个一个的缓存页和一个一个与其对应的描述数据（控制块）。此时的buffer pool像一个干净的本子，没有书写任何内容。
# MySQL临时表
MySQL临时表在很多场景中都会用到，比如用户自己创建的临时表用于【保存临时数据】，以及MySQL内部在执行【复杂SQL】时，需要借助临时表进行【分组、排序、去重】等操作，临时表具有一下几个特点：
1.临时表不能通过show tables查看，在服务器重启之后，所有的临时表将全部被销毁。
2.临时表是每个进程独享的，当前进程（客户端）创建的临时表，其他进程（客户端）是查不到临时表里面的数据的，所以不同客户端可以创建同名的临时表。
# 临时表分类
- 外部临时表
- 内部临时表
- 复杂的sql中很容易产生临时表
  使用GROUP BY分组，且分组字段没有索引时
  使用DISTINCT查询。
  使用UNION进行结果合并，辅助去重。
  union all不会使用零时表，因为他不需要去重
  union--连接表，对行操作。
  union--将两个表做行拼接，同时自动删除重复的行。
  union all---将两个表做行拼接，保留重复的行
# 内存临时表使用memery引擎（Memory引擎不支持BOLB和TEXT类型）；
# 磁盘临时表默认使用innodb引擎：
- 数据表中包含BLOB/TEXT列；
- 在 GROUP BY 或者 DSTINCT 的列中有超过 512字符的字符类型列；
- 在SELECT、UNION、UNION ALL查询中，存在最大长度超过512的列（对于字符串类型是512个字符，对于二进制类型则是512字节）；
# MySQL事务
隐式事务
SHOW VARIABLES LIKE 'autocommit';
显式事务
显式事务由我们【自己控制】事务的【开启，提交，回滚】等操作，我们创建一个表，同时展示事务的基础语法，如下：
只读事务
只读事务模式之后，事务执行期间任何【insert】或者【update】语句都是不允许的；
读写事务

# 保存点
我们可以使用savepoint 关键字在事务执行中新建【保存点】，之后可以使用rollback向任意保存点回滚。
```mysql
start transaction;
UPDATE user set balance = balance - 200 where id = 1;
savepoint a;
UPDATE user set balance = balance + 200 where id = 2;
rollback to a;
```
Mysql是不支持嵌套事务的
事务四大特征（ACID）:
原子性（Atomicity）
一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。如果事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样，这个很好理解。
一致性（Consistency）
在事务【开始之前和结束以后】，数据库的完整性没有被破坏，数据库状态应该与业务规则保持一致
隔离性（Isolation）
数据库【允许多个并发事务同时对其数据进行读取和修改】，隔离性可以防止多个事务在并发修改共享数据时产生【数据不一致】的现象，这里要联想到我们学习过的多线程。
持久性（Durability）
事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

事务隔离级别:
在多个事务并发操作相同的表数据时,为了让多个事务都可以得到正确的结果，不会因为互相的交叉操作产生干扰，同时还要保证一定的执行效率，故而提出了不同的隔离级别。
在mysql中查看和设置【事务的隔离级别】
```mysql
-- 查看全局和当前事务的隔离级别
SELECT @@global.transaction_isolation, @@transaction_isolation_isolation;
show variables like 'transaction_isolation';
--5.7   tx_isolation
--8.0   transaction_isolation

-- 设置下一个事务的隔离级别
SET transaction isolation level read uncommitted;
SET transaction isolation level read committed;
set transaction isolation level repeatable read;
SET transaction isolation level serializable;
-- 设置当前会话的隔离级别
SET session transaction isolation level read uncommitted;
SET session transaction isolation level read committed;
set session transaction isolation level repeatable read;
SET session transaction isolation level serializable;
-- 设置全局事务的隔离级别
SET GLOBAL transaction isolation level read uncommitted;
SET GLOBAL transaction isolation level read committed;
set GLOBAL transaction isolation level repeatable read;
SET GLOBAL transaction isolation level serializable;


其中，SESSION 和 GLOBAL 关键字用来指定修改的事务隔离级别的范围：
SESSION：表示修改的事务隔离级别将应用于当前 session（当前 cmd 窗口）内的所有事务；
GLOBAL：表示修改的事务隔离级别将应用于所有 session（全局）中的所有事务，且当前已经存在的 session 不受影响；
如果省略 SESSION 和 GLOBAL，表示修改的事务隔离级别将应用于当前 session 内的下一个还未开始的事务。
```
**脏读：**指的是一个事务读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，读到的数据不一定准确。
**不可重复读**的官方解释是：【一个事务】（A事务）修改了【另一个未提交事务】（B事务）读取过的数据。那么B事务【再次读取】，会发现两次读取的数据不一致。也就是说在一个原子性的操作中一个事务两次读取相同的数据，却不一致，一行数据不能重复被读取。主要是【update】语句，会导致不可重复读。
**幻读：**一个事务按照某些条件进行查询，事务提交前，有另一个事务插入了满足条件的其他数据，再次使用相同条件查询，却发现多了一些数据，就像出现了幻觉一样。幻读主要针对针对delete和insert语句。
`不可重复读强调的是两次读取的数据【内容不同】，幻读前调的是两次读取的【行数不同】`
# Read uncommitted（读未提交）
一个事务可以读取其他【未提交的事务】修改的数据，这种隔离级别最低，一般情况下，数据库隔离级别都要高于该级别，该隔离级别下，可能会存在脏读、不可重复度，幻读的问题。
# Read committed（读已提交）
当前事务只能读到别的事务已经提交的数据，该隔离级别可能会产生不可重复读和幻读。
# Repeatable read（可重复读）
同一个事务中发出同一个SELECT语句【两次或更多次】，那么产生的结果数据集总是相同的，在RR隔离级别中可能出现幻读。
# Serializable（串行化）
事务A和事务B，事务A在操作数据库时，事务B只能排队等待
这种隔离级别很少使用，吞吐量太低，用户体验差
这种级别可以避免“幻读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发。

# B-树有如下特点:
所有键值分布在整颗树中；
任何一个关键字出现且只出现在一个结点中；
搜索有可能在非叶子结点结束；
在关键字全集内做一次查找，性能逼近二分查找；

# B+树
B+树】是【B-树】的变体，也是一种多路搜索树, 它与 B- 树的不同之处在于:
所有关键字存储在叶子节点
为所有叶子结点增加了一个双向指针

# 索引介绍
帮助MySQL高效获取数据的数据结构(有序)。
优点：
提高数据`检索效率`，降低数据库的IO成本
通过索引列对数据进行排序，降低`数据排序的成本`，降低CPU的消耗
缺点：
索引列也是要占用空间的
索引大大提高了查询效率，但`降低了更新的速度`，比如 INSERT、UPDATE、DELETE

InnoDB:B+Tree索引,Full-text(全文索引)
MyISAM:B+Tree索引,R-Tree索引（空间索引）,Full-text
Memory:B+Tree索引,Hash索引

# 二叉树和红黑树
红黑树是一颗自平衡二叉树，大数据量情况下，层级较深，检索速度慢；
在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree；

# B-tree : 以5阶的B-tree为例：
5(n)阶的B树，每一个节点最多存储4个key（n-1），对应5个指针(n)。
一旦节点存储的key数量到达5(n)，就会裂变，中间元素向上分裂。
在B树中，非叶子节点和叶子节点都会存放数据。
# B+Tree：是b-tree的变种
所有的数据都会出现在叶子节点，叶子节点形成一个单向链表，非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的；
# mysql的B+tree
在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序
# Hash索引
将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中；
映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。
特点：
Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）
无法利用索引完成排序操作
查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引
# 为什么InnoDB存储引擎选择使用B+tree索引结构
相对于二叉树，层级更少，搜索效率高；
对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
相对Hash索引，B+tree支持范围匹配及排序操作；
# 索引的分类
主键索引：针对于表中主键创建的索引，一个
唯一索引：避免同一个表中某数据列中的值重复，多个，
常规索引：快速定位特定数据，多个，
全文索引： 全文索引查找的是文本中的关键词，而不是比较索引中的值， 多个
# 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：
`聚集索引(Clustered Index)`：将数据存储与索引放一块，索引结构的叶子节点保存了行数据，一个
`二级索引(Secondary Index)`：将数据与索引分开存储，索引结构的叶子节点关联的是该字段值对应的主键值。，多个
# 聚集索引选取规则:
如果存在主键，主键索引就是聚集索引
如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引。

# select * from 表 where name="Arm";
具体过程如下:
由于是根据name字段进行查询，所以先根据name='Arm'到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值 10。
由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行数据直接返回；
# 回表查询： 
这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。

# 优化分析
show index from tb_user;
CREATE INDEX idx_email ON tb_user(email);

第一步：通过查询SQL的执行频率
SHOW GLOBAL STATUS LIKE 'Com_______';查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次；
我们就能够知道当前数据库到底是增删改为主，还是查询为主（可以建立索引）。
第二步：定位哪些查询语句需要优化

1.开启慢查询日志；show variables like 'slow_query_log';
### 开启MySQL慢日志查询开关
slow_query_log=1
### 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
2.通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。
第三步：索引效率
EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。
Explain 执行计划中各个字段的含义: key采用的索引，null标示索引没有生效；
# 最左前缀法则
是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在；否则索引无效；
# 前缀索引
当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率
# 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。
因为索引只会走一种索引，如果是单列索引，其他字段的值获取就需要走回表查询，如果是联合索引，只需要在二级索引中直接返回字段的值，避免回表查询；
# 索引设计原则
针对于数据量较大，且查询比较频繁的表建立索引。
针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

# MySQL中的锁
锁是计算机协调多个进程或线程并发访问某一资源的机制；
全局锁：锁定数据库中的所有表。
表级锁：每次操作锁住整张表。
行级锁：每次操作锁住对应的行数据。

# 全局锁
全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。
- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
- 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。

```msql
flush tables with read lock;
unlock tables;
```
# 表级锁
表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。
## 表锁:
表共享`读锁`（read lock）
表独占`写锁`（write lock）
加锁：lock tables 表名 read/write。
释放锁：unlock tables / 客户端断开连接

## 元数据锁（meta data lock，MDL）:
某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。
## 意向锁
客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。
而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了;

# 行锁
每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。
行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。
行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

# 共享锁
select...lock in share mode，加共享锁
共享锁与共享锁之间（不同事务之间的）兼容。
共享锁与排他锁之间互斥。
排它锁与排他锁之间互斥；
无索引行锁升级为表锁

# MySQL主从复制
主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。
MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。

MySQL 复制的优点主要包含以下三个方面：
- 主库出现问题，可以快速切换到从库提供服务。
- 实现读写分离，降低主库的访问压力。
- 可以在从库中执行备份，以避免备份期间影响主库服务。
# 复制分成三步：
Master 主库在事务提交时，会把数据变更记录在`二进制日志文件` Binlog 中。
从库读取主库的二进制日志文件 Binlog ，写入到从库的`中继日志` Relay Log 。
slave`重做中继日志中的事件`，将改变反映它自己的数据。


# 性能优化
select count(*) from logs;

# limit优化
```sql
select * from logs limit 30000, 30;
```
子查询优化后
```sql
explain select * from logs l,(select id from logs group by id limit 30000, 30) a where l.id = a.id;


show index from logs;
create index idx_logs_user on logs(operate_user);
``

复合索引：最左前缀法则

# 分析原则
基于影响结果集的理解去优化，不论从数据结构，代码，还是涉及产品策略上，都需要贯彻下去。
涉及 limit $start,$num 的搜索，如果$start 巨大，则影响结果集巨大，搜索效率会非常低;
先从索引结构中获得 limit $start,$num；再用 in 操作或基于索引序的二次搜索。
```sql  ORDER BY displayorder DESC, lastpost ASC ``` 一个是 ASC，一个是 DESC 时，其排序无法在索引中完成;

# Copy to tmp table如何规避
索引及现有结构无法涵盖查询条件，才会建立一个临时表来满足查询要求，产生巨大的恐怖的 i/o 压力。
Copy to tmp table 通常与连表查询有关，建议逐渐习惯不使用连表查询；

# 慢查询日志的rows_exmianed
# explain 执行计划
# show profiles for query
# show proesslist

# 读写分离
mysql在主从复制的基础上，使用读写分离降低单台节点的压力，从而提高访问效率；

# 为什么自增主键不连续
在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化;
发生事务回滚（自增值不能回退，因为并发插入数据时，回退自增ID可能造成主键冲突）;
发生唯一键冲突（由于表的自增值已变，但是主键发生冲突没插进去，下一次插入主键=现在变了的子增值+1，所以不连续;
自增ID有序，会按顺序往最后插入，而UUID无序，随机生成，随机插入，会造成频繁页分裂，内存碎片化，大量随机IO

覆盖索引：索引字段覆盖了查询语句涉及的字段，直接通过索引文件就可以返回查询所需的数据，不必通过回表操作。
回表：通过索引找到主键，再根据主键id去主键索引查。
索引下推：在根据索引查询过程中就根据查询条件过滤掉一些记录，减少最后的回表操作
索引失效场景？
以“%”开头的like语句，索引无效
or语句前后没有同时使用索引
列类型是字符串，一定要在条件中将数据用引号引用，否则失效（隐式转换）
组合索引要遵守最左前缀原则——不使用第一列索引 失效
在索引字段上使用not，<>，!= （对它处理是全表扫描）
对索引字段进行计算操作，字段使用函数也会失效

非聚簇索引一定会回表查询吗
查询字段全部命中索引，覆盖索引，不走回表，直接从索引得到结果，不要查数据文件
先删索引，再删无用数据，再创建索引
查询会以页为单位将数据页加载进内存，不需要一条记录一条记录读取磁盘。然后唯一索引根据条件查询到记录时就返回结果，普通索引查到第一条记录往后遍历直到不满足条件，由于都在内存中，不需要磁盘读取那么大开销，带来的额外查询开销忽略不计，所以查询性能几乎一致
写多读少，选用普通索引更好，可以利用change buffer进行性能优化减少磁盘IO，将更新操作记录到change bufer，等查询来了将数据读到内存再进行修改.

mysql分为server层与存储引擎层，server层包含连接器、分析器、优化器、执行器。

# 主从同步















