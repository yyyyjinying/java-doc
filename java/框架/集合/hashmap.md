# hashmap
HashMap的底层有数组 + 链表(红黑树)组成，数组的大小可以在构造方法时设置，默认大小为16，数组中每一个元素就是一个链表，jdk7之前链表中的元素采用头插法插入元素，jdk8之后采用尾插法插入元素，由于插入的元素越来越多，查找效率就变低了，所以满足某种条件时，链表会转换成红黑树。随着元素的增加，HashMap的数组会频繁扩容，如果构造时不赋予加载因子默认值，那么负载因子默认值为0.75,数组扩容的情况如下:
1:当添加某个元素后，数组的总的添加元素数大于了 数组长度 * 0.75(默认,也可自己设定),数组长度扩容为两倍。(如开始创建HashMap集合后，数组长度为16，临界值为16 * 0.75 = 12，当加入元素后元素个数超过12，数组长度扩容为32，临界值变为24)
2：在没有红黑树的条件下，添加元素后数组中某个链表的长度超过了8，数组会扩容为两倍.(如开始创建HashMAp集合后，假设添加的元素都在一个链表中，当链表中元素为8时，再在链表中添加一个元素，此时若数组中不存在红黑树，则数组会扩容为两倍变成32，假设此时链表元素排列不变，再在该链表中添加一个元素，数组长度再扩容两倍，变为64，假设此时链表元素排列还是不变，则此时链表中存在10个元素，这是HashMap链表元素数存在的最大值，此时，再加入元素，满足了链表树化的两个条件(1:数组长度达到64, 2:该链表长度达到了8)，该链表会转换为红黑树
HashMap创建的底层原理
1:首先创建HashMap集合时，在不手动赋值的情况下会先设置默认负载因子0.75；
2.向集合值添加元素会调用putVal()方法，前三个参数分别为hash(key),key,value，即hash值，键值对。
3.hash(key)方法计算hash值：计算方法是键的hashCode()方法与高位16进行异或运算得到hash值
4.进入putVal方法，首先看上半部分
首先判断数组中是否已经创建，此时还创建数组，所以此时调用（resize()方法设置初始容量），将元素存储在i = (n - 1) & hash的下标链表中，因为此时为加入元素所以table[i]一定是null,元素一定会存入到数组中。size代表了此时集合中已经加入的元素个数，当其值大于了临界值，threshold(此时为12)时，会调用resize()方法进行二倍扩容；第二次插入元素，判断链表中头元素与当前插入的元素是否是同一个元素(hash()方法与equals()方法比较)，相同替换；不相同，判断当前数组中的结点是链表还是红黑树，如果是红黑树，就按红黑树的添加方式添加。如果是琏表，进入一个死循环，死循环结束有两种方式；1.用尾插法在链表末尾插入这个添加的元素，然后，判断链表中元素是否达到了8，在数组容量小于64时，数组会调用resize()方法扩容为2倍，不是就转化为红黑树；2.如果添加元素相同的元素(euqals()方法比较),直接跳出循环，并覆盖掉链表中元素的“值；
```java
/**
  * 返回一个值，大于等于传入的数字的一个2的次幂的数字，你传入15返回16，传入7返回8、
  * 保证了容量是2的次幂。为了后来计算hash槽做准备
  */
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```
// 初始化容量(initialCapacity)和负载因子(loadFactor)
构造的整个过程当中，并没有初始化hash表table,

2的N次方-1得到低位全是1的数字； 
比如：（2^4=16）2的4次方-1得到15与任何一个数字与运算，高位不运算，低位运算，都会得到一个0-15（容量减1）的数字；
hash的值是通过低位和高位进行异或运算；
```java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
# 扩容原理
1.创建一个新的Entry空数组，长度是原数组的2倍。2.遍历原Entry数组，把所有的Entry重新Hash到新数组。
要重新Hash，不直接复制过去，因为长度扩大以后，Hash的规则也随之改变。
# 头插法和尾插法
当HashMap要在链表里插入新的Entry时，在Java 8之前是将Entry插入到链表头部，在Java 8开始是插入链表尾部（Java 8用Node对象替代了Entry对象）。
Java 7插入链表头部，是考虑到新插入的数据，更可能作为热点数据被使用，放在头部可以减少查找时间。
Java 8改为插入链表尾部，原因就是防止环化。因为resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。
# 迭代器原理
当集合遍历时，首先通过调用集合中的iterator（）方法获得迭代器对象，然后使用hasNext（）方法判断集合中是否存在下一个元素。如果存在，则调用next（）方法将元素取出。否则说明遍历已经到达了集合末尾，停止遍历元素。iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，在调用Iterator的next（）方法之前，迭代器的索引位于第一个元素前，不指向任何元素。每调用一次next（），迭代器的索引会指向下一个元素并将该元素返回，直到hasNext（）方法返回false，表示到达了集合的末尾，终止对集合的遍历。
# 增强for循环使用迭代器
for循环和迭代器 Iterator对比
for each 以用来处理集合中的每个元素而不用考虑集合定下标。就是为了让用 Iterator 简单。但是删除的时候，区别就是在 remove，循环中调用集合remove会导致原集合变化导致错误，而应该用迭代器的 remove 方法。
for 循环和迭代器 Iterator对比：
①采用 ArrayList 对随机访问比较快，而for循环中的get()，采用的即是随机访问的方法，因此在 ArrayList 里，for循环较快
②采用 LinkedList 则是顺序访问比较快，Iterator 中的 next()，采用的即是顺序访问的方法，因此在 LinkedList 里，使用 Iterator 较快。
③从数据结构角度分析，for循环适合访问顺序结构，可以根据下标快速获取指定元素。而 Iterator 适合访问链式结构，因为迭代器是通过next()和Pre()来定位的，可以访问没有顺序的集合。
④使用 Iterator 的好处在于可以用相同方式去遍历集合中元素，而无需考虑集合类的内部实现(只要它实现了 java.lang.Iterable 接口)。如果使用 Iterator 来遍历集合中元素，一旦不再使用 List 转而使用 Set 来组织数据，那遍历元素的代码不用做任何修改；如果使用 for 来遍历，那所有遍历此集合的算法都得做相应调整。因为List有序，Set无序，结构不同，它们的访问算法也不一样。(由此也说明遍历和集合本身分离了)
# ArrayList和LinkedList的区别？
是 List 接口的两种不同实现，并且两者都不是线程安全的。
ArrayList 内部使用的动态数组来存储元素，LinkedList 内部使用的双向链表来存储元素，这也是 ArrayList 和 LinkedList 最本质的区别.
ArrayList的扩容需有拷贝原先的数据，System.arraycopy；
总结 区别：
1、二者实现结构不同arraylist是基于数组，linkedlist是基于链表，他们的特性也是由其数据结构决定的。
2、随机遍历访问时linkedlist的性能要低于arraylist.
3、arraylist的初始化时默认10容量，而linkedlist默认初始化为空。
4、linkedlist的增删要优于arraylist

ArrayList 扩容机制：无参构造创建的ArrayList的初始空间为0，在添加第一个元素的时候空间会默认为10，之后扩容会为当前容量的1.5倍；
Vector 扩容机制：结论：无参构造默认空间为10，每次扩大一倍。
LinkedList 扩容机制：LinkedList是一个双向链表,没有初始化大小,也没有扩容的机制,就是一直在前面或者后面新增就好。
HashMap的初始容量为16，扩容因子为0.75，扩容为原来容量的两倍。

# 时间复杂度
算法的时间复杂度（Time complexity）是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大 O 符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 n (必须比n0大）的输入，它至多需要 的时间运行完毕，那么它的渐近时间复杂度是O(n3);

# 增强for循环其实也是使用了迭代器for(int a:b)
# 迭代中删除元素
1.for循环中删除.1-1:回调指针,1-2:逆序遍历;
2.使用迭代器删除元素;(iterator.remove();)
# Arrays.asList(...)返回的是ArrayList吗,不是同一个，是Arrays中的内部类；
# 并发修改异常
迭代器是依赖于集合而存在的，在判断成功后，集合的中新添加了元素，而迭代器却不知道，所以就报错了，这个错叫并发修改异常。
- 迭代器迭代元素，迭代器修改元素
- 集合遍历元素，集合修改元素(普通for)
