# TPS
Transactions Per Second，意思是每秒事务数。一个事务是指客户端向服务器发送请求然后服务器做出反应的过程，具体的事务定义，可以是一个接口、多个接口、一个业务流程等等。以单接口定义为事务举例，每个事务包括了如下3个过程：
（1）向服务器发请求
（2）服务器自己的内部处理（包含应用服务器、数据库服务器等）
（3）服务器返回结果给客户端
最大 TPS 以及接口响应时间
# QPS：
Queries Per Second，意思是每秒查询率。指一台服务器每秒能够响应的查询次数，用于衡量特定的查询服务器在规定时间内所处理流量多少，主要针对专门用于查询的服务器的性能指标

数据量大
写入操作频繁
价值较低的数据, 对事务性要求不高
具体的应用场景:

社交场景, 使用 MongoDB 存储存储用户信息, 以及用户发表的朋友圈信息, 通过地理位置索引实现附近的人, 地点等功能.
游戏场景, 使用 MongoDB 存储游戏用户信息, 用户的装备, 积分等直接以内嵌文档的形式存储, 方便查询, 高效率存储和访问.
物流场景, 使用 MongoDB 存储订单信息, 订单状态在运送过程中会不断更新, 以 MongoDB 内嵌数组的形式来存储, 一次查询就能将订单所有的变更读取出来.
物联网场景, 使用 MongoDB 存储所有接入的智能设备信息, 以及设备汇报的日志信息, 并对这些信息进行多维度的分析.
视频直播, 使用 MongoDB 存储用户信息, 点赞互动信息等；
新应用, 需求会变, 数据模型无法确定, 想快速迭代开发；
应用需要 2000 - 3000 以上的读写QPS（更高也可以）；
应用需要 TB 甚至 PB 级别数据存储；
应用发展迅速, 需要能快速水平扩展；
应用要求存储的数据不丢失；
应用需要 99.999% 高可用；
应用需要大量的地理位置查询, 文本查询；
# MongoDB
是一个开源, 高性能, 无模式的文档型数据库, 当初的设计就是用于简化开发和方便扩展, 是NoSQL数据库产品中的一种.是最 像关系型数据库（MySQL）的非关系型数据库. 它支持的数据结构非常松散, 是一种类似于 JSON 的 格式叫BSON, 所以它既可以存储比较复杂的数据类型, 又相当的灵活. MongoDB中的记录是一个文档, 它是一个由字段和值对（ﬁeld:value）组成的数据结构.MongoDB文档类似于JSON对象, 即一个文档认 为就是一个对象.字段的数据类型是字符型, 它的值除了使用基本的一些类型外, 还可以包括其他文档, 普通数组和文档数组.
key-value：
key: 字段的数据类型是字符型;
value: 值除了使用`基本类型`以外, 还包括其它`文档,` 普通`数组`以及`文档数组`
数据库 (database):是一个仓库, 存储集合 (collection);
集合 (collection):类似于数组, 在集合中存放文档;
文档 (document):文档型数据库的最小单位, 通常情况, 我们存储和操作的内容都是文档;
在 MongoDB 中, 数据库和集合都不需要手动创建, 当我们创建文档时, 如果文档所在的集合或者数据库不存在, 则会自动创建数据库或者集合

# Built-In Roles（内置角色）：
1. 数据库用户角色：read、readWrite;
2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；
3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；
 4. 备份恢复角色：backup、restore；
 5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase
 6. 超级用户角色：root  
 // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）
 7. 内部角色：__system
 8. 
# 具体角色的功能：
Read：允许用户读取指定数据库
readWrite：允许用户读写指定数据库
dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile
userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户
clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。
readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限
readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限
userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限
dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。
root：只在admin数据库中可用。超级账号，超级权限

# 添加管理员，其拥有管理用户和角色的权限
db.createUser({ user: 'root', pwd: 'root', roles: [ { role: "root", db: "admin" } ] })

# 进行认证
mongo -u "root" -p "root" --authenticationDatabase "admin"

# 通过root用户-》添加普通用户
use admin
db.createUser({ user: 'house', pwd: 'oudqBFGmGY8pU6WS', roles: [ { role: "readWrite", db: "house" } ] });

# 通过tanhua用户登录进行测试
mongo -u "house" -p "oudqBFGmGY8pU6WS" --authenticationDatabase "admin"

# jinyun
db.createUser({ user: 'jinyun', pwd: 'oudqBFGmGY8pU6WS', roles: [ { role: "readWrite", db: "jinyun" } ] });
mongo -u "jinyun" -p "oudqBFGmGY8pU6WS" --authenticationDatabase "admin"



```mongodb
# mongo
# db
# use admin
# db.dropDatabase()

查看数据
>show dbs
admin   0.000GB
config  0.000GB
house   0.010GB
local   0.000GB
切换数据库
>use house 
查看数据库中的集合
>show collections
tb_business_circle
tb_community
tb_district
tb_house
创建集合
> db.createCollection("aaa")
{ "ok" : 1 }
> show collections
aaa
删除集合
> db.aaa.drop()
true
```
# 数据模型
字符串
对象ID：ObjectId()
布尔值
数组：["a","b","c"]
64位浮点型： 3.12345
null
undefined
正则表达式：/foobar/i
二进制数据
最大值和最小值：BSON的一个特殊类型

# MongoDB 的特点
## 高性能
MongoDB 提供高性能的数据持久化
嵌入式数据模型的支持减少了数据库系统上的 I/O 活动
索引支持更快的查询, 并且可以包含来自嵌入式文档和数组的键 (文本索引解决搜索的需求, TTL 索引解决历史数据自动过期的需求, 地理位置索引可以用于构件各种 O2O 应用)
mmapv1, wiredtiger, mongorocks (rocksdb) in-memory 等多引擎支持满足各种场景需求
Gridfs 解决文件存储需求
## 高可用
MongoDB 的复制工具称作副本集 (replica set) 可以提供自动故障转移和数据冗余
## 高扩展
分片将数据分布在一组集群的机器上 (海量数据存储, 服务能力水平扩展)
MongoDB 支持基于片键创建数据区域, 在一个平衡的集群当中, MongoDB 将一个区域所覆盖的读写只定向到该区域的那些片
MongoDB支持丰富的查询语言, 支持读和写操作(CRUD), 比如数据聚合, 文本搜索和地理空间查询等. 无模式（动态模式）, 灵活的文档模型
当使用 use articledb 的时候. articledb 其实存放在内存之中, 当 articledb 中存在一个 collection 之后, mongo 才会将这个数据库持久化到硬盘之中.

#  文档基本 CRUD
使用 db.<collection_name>.insertOne() 向集合中添加一个文档, 参数一个 json 格式的文档
使用 db.<collection_name>.insertMany() 向集合中添加多个文档, 参数为 json 文档数组
db.inventory.insertMany([
   { item: "journal", qty: 25, tags: ["blank", "red"], size: { h: 14, w: 21, uom: "cm" } },
   { item: "mat", qty: 85, tags: ["gray"], size: { h: 27.9, w: 35.5, uom: "cm" } },
   { item: "mousepad", qty: 25, tags: ["gel", "blue"], size: { h: 19, w: 22.85, uom: "cm" } }
])
db.inventory.insertMany([
   { item: "journal", qty: 25, tags: ["blank", "red"]}
   ])


db.inventory.find( {} )
select * from inventory;
db.inventory.find( {status: "D"} )
SELECT * FROM inventory WHERE status = "D"

db.inventory.find().pretty()

// 默认会修改第一条
db.document.update({ userid: "30", { $set {username: "guest"} } })

// 修改所有符合条件的数据
db.document.update( { userid: "30", { $set {username: "guest"} } }, {multi: true} )

# 文档排序和投影 (sort & projection)
投影 Projection
有些情况, 我们对文档进行查询并不是需要所有的字段, 比如只需要 id 或者 用户名, 我们可以对文档进行“投影”
db.users.find( {}, {age: 1, _id: 0} )
db.posts.find().sort({ title : -1 }).limit(2).pretty()

# 插入行为 
创建集合: 如果集合当前不存在，则插入操作将创建该集合。 
_id领域: 在MongoDB中，存储在集合中的每个文档都需要一个唯一的_id字段作为主键。如果插入的文档遗漏了_id字段，MongoDB驱动会自动为_id字段生成一个ObjectId。 
这也适用于通过upsert: true的更新操作插入的文档。 
原子性: MongoDB中的所有写操作都是单个文档级别上的原子操作

# MongoDB 的索引
4.1 概述
索引支持在 MongoDB 中高效地执行查询.如果没有索引, MongoDB 必须执行全集合扫描, 即扫描集合中的每个文档, 以选择与查询语句 匹配的文档.这种扫描全集合的查询效率是非常低的, 特别在处理大量的数据时, 查询可以要花费几十秒甚至几分钟, 这对网站的性能是非常致命的.

如果查询存在适当的索引, MongoDB 可以使用该索引限制必须检查的文档数.

索引是特殊的数据结构, 它以易于遍历的形式存储集合数据集的一小部分.索引存储特定字段或一组字段的值, 按字段值排序.索引项的排 序支持有效的相等匹配和基于范围的查询操作.此外, MongoDB 还可以使用索引中的排序返回排序结果.

MongoDB 使用的是 B Tree, MySQL 使用的是 B+ Tree

创建一个升序索引
db.records.createIndex( { score: 1 } )
在嵌入字段上创建索引
{
  "_id": ObjectId("570c04a4ad233577f97dc459"),
  "score": 1034,
  "location": { state: "NY", city: "New York" }
}
db.records.createIndex( { "location.state": 1 } )
db.records.find( { "location.state": "CA" } )
db.records.find( { "location.city": "Albany", "location.state": "NY" } )
在嵌入式文档创建索引

查看索引
db.inventory.getIndexes()
删除索引
db.inventory.dropIndex("item_1")
// create index
db.<collection_name>.createIndex({ userid : 1, username : -1 })

// retrieve indexes
db.<collection_name>.getIndexes()

// remove indexes
db.<collection_name>.dropIndex(index)

// there are 2 ways to remove indexes:
// 1. removed based on the index name
// 2. removed based on the fields

db.<collection_name>.dropIndex( "userid_1_username_-1" )
db.<collection_name>.dropIndex({ userid : 1, username : -1 })

// remove all the indexes, will only remove non_id indexes
db.<collection_name>.dropIndexes()

# 索引的类型
单字段索引：MongoDB 支持在文档的单个字段上创建用户定义的升序/降序索引, 称为单字段索引 Single Field Index

复合索引：
# 其他索引

索引使用
 执行计划
db.<collection_name>.find( query, options ).explain(options)
"stage" : "COLLSCAN"全表扫描
"stage" : "IXSCAN", 基于索引的扫描

## 地理空间索引（Geospatial Index）
为了支持对地理空间坐标数据的有效查询, MongoDB 提供了两种特殊的索引: 返回结果时使用平面几何的二维索引和返回结果时使用球面几何的二维球面索引.

## 文本索引（Text Indexes）
MongoDB 提供了一种文本索引类型, 支持在集合中搜索字符串内容.这些文本索引不存储特定于语言的停止词（例如 “the”, “a”, “or”）, 而将集合中的词作为词干, 只存储根词.

## 哈希索引（Hashed Indexes）
为了支持基于散列的分片, MongoDB 提供了散列索引类型, 它对字段值的散列进行索引.这些索引在其范围内的值分布更加随机, 但只支持相等匹配, 不支持基于范围的查询.


# 聚合管道 
聚合管道由一个或多个处理文档的阶段组成: 
每个阶段对输入文档执行一个操作。例如，阶段可以过滤文档、分组文档和计算值。 
从一个阶段输出的文档被传递到下一个阶段。 
聚合管道可以返回文档组的结果。例如，返回总数、平均值、最大值和最小值。 
从MongoDB 4.2开始，如果使用“使用聚合管道更新”中所示的阶段，就可以使用聚合管道更新文档。

# 如何使用pojo读取和写入文档
pojo通常用于数据封装，将业务逻辑与数据表示分开。