# 工作模式
RabbitMQ提供了6种模式：
`简单模式`，
`Work queues工作队列模式`(包工头):多个消费端共同消费同一个队列中的消息。应用场景：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度;消费者之间对于同一个队列消息的关系是竞争的关系
`publish/subscribe 订阅发布模式类型（微博）`:
而在订阅模型中，多了一个exchange角色，而且过程略有变化：

P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）
C：消费者，消息的接受者，会一直等待消息到来。
Queue：消息队列，接收消息、缓存消息。
Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：
Fanout：广播，将消息交给所有绑定到交换机的队列
Direct：定向，把消息交给符合指定routing key 的队列
Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列
Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！
发布订阅模式： 1、每个消费者监听自己的队列。 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收 到消息
发布订阅模式与工作队列模式的区别
1、工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。
2、发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。
3、发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机;
```java
默认是广播模式
channel.basicPublish(FANOUT_EXCHAGE, "",null,  msg.getBytes());
```
`Routing路由模式（分布式日志收集系统）`:交换机的type=direct路由模式特点：
队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）,消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey;消息会转发到符合routing key的队列,消费者消费指定的队列；
`Topics通配符模式`:
Topic类型与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符；Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert
通配符规则：
#：匹配一个或多个词
*：匹配不多不少恰好1个词
Topic主题模式可以实现 Publish/Subscribe发布与订阅模式 和 Routing路由模式 的功能；只是Topic在配置routing key 的时候可以使用通配符，显得更加灵活。
RPC远程调用模式（远程调用，不太算MQ；暂不作介绍）；
官网对应模式介绍：https://www.rabbitmq.com/getstarted.html
RabbitMQ工作模式：
交换机支持四种类型BuiltinExchangeType： DIRECT("direct"), FANOUT("fanout"), TOPIC("topic"), HEADERS("headers");
1）简单模式 HelloWorld
一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。
2）工作队列模式 Work Queue
一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。
3）发布订阅模式 Publish/subscribe
需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。
4）路由模式 Routing
需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列。
5）通配符模式 Topic
需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列。
# 消息可靠性投递
在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。confirm 确认模式(publisher-confirms="true" 开启 确认模式),return 退回模式(publisher-returns="true" 开启 退回模式)
rabbitmq 整个消息投递的路径为:​ producer ---> rabbitmq broker ---> exchange ---> queue ---> consumer;消息从 producer 到 exchange 则会返回一个 confirmCallback;消息从 exchange 到 queue 投递失败则会返回一个 returnCallback ;我们将利用这两个 callback 控制消息的可靠性投递
# 确认模式
设置ConnectionFactory的publisher-confirms="true" 开启 确认模式。使用rabbitTemplate.setConfirmCallback设置回调函数。当消息发送到exchange后回调confirm方法。在方法中判断ack，如果为true，则发送成功，如果为false，则发送失败，需要处理。
# 退回模式
设置ConnectionFactory的publisher-returns="true" 开启 退回模式；使用rabbitTemplate.setReturnCallback设置退回函数，当消息从exchange路由到queue失败后，如果设置了rabbitTemplate.setMandatory(true)参数，则会将消息退回给producer。并执行回调函数returnedMessage。
# Consumer ACK
`自动确认`是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。
如果设置了`手动确认`方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。
```java
channel.basicAck(deliveryTag,false);方法确认签收消息
channel.basicReject(deliveryTag,true);
channel.basicNack(tag,false,true); // 重新确认
```
# TTL
从消费者的角度来说，我们也可以这样理解：在消息被设置了 TTL 之后，如果这个消息的等待时间超过了 TTL ，则这个消息就不会被任何消费者消费；从生产者的角度来说，生产者发送了一条消息到 RabbitMQ Server 中，且已经设置了 TTL ，如果这个消息的等待时间超过了 TTL ，即使有消费者来接收消息，这个消息也不会被接收，同时，生产者也不会再次发送相同的消息。
设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。
设置消息过期时间使用参数：expiration。单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期。
如果两者都进行了设置，以时间短的为准。
# 死信队列 
英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。
消息成为死信的三种情况：
1.队列消息长度到达限制；
2.消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false；
3.原队列存在消息过期设置，消息到达超时时间未被消费；

# 消息可靠性保障
# 消息幂等性处理
幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。
在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。
在本教程中使用 乐观锁机制 保证消息的幂等操作

# RAM node 和 disk node 的区别？
RAM node 仅将RabbitMQ 基础构件(exchange、queue、binding)相关的数据保存在内存中；上唯一会存储到磁盘上的元数据是 cluster 中使用的 disk node 的地址；
disk node 会在内存和磁盘中均进行存储；
# RabbitMQ 上的一个 queue 中存放的 message 是否有数量限制？
可以认为是无限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降；
# RabbitMQ 概念里的 channel、exchange 和 queue 这些东东是逻辑概念，还是对应着进程实体？这些东东分别起什么作用？
queue 具有自己的 erlang 进程；exchange 内部实现为保存 binding 关系的查找表;
exchange 内部实现为保存 binding 关系的查找表;routing_key 将 message 投递给queue,AMQP 命令都是通过 channel 发送的;每一个 channel 运行在一个独立的线程上，多线程共享同一个 socket;
# routing_key 和 binding_key 的最大长度是多少？
255 字节。
# MQ的优点
异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。
应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。
流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。
日志处理 - 解决大量日志传输。
消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实
现点对点消息队列，或者聊天室等。
# 解耦、异步、削峰是什么
解耦：就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其 实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。
异步：A系统依赖bcd系统，不需要完全等待bcd处理完就可以通过mq返回结果；
削峰：可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求，减少高峰时期对服务器压力。
#  消息队列有什么缺点
1. 系统可用性降低
本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低；
2. 系统复杂度提高
加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。
3. 一致性问题
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。

# Kafka的的消息中间件的功能明显较少,优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。
# 消息的顺序问题
消息有序指的是可以按照消息的发送顺序来消费。假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先 于 M2 被消费，怎么做？
# 消息的重复问题
造成消息重复的根本原因是：网络不可达。消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日
志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。
# RabbitMQ基本概念
Broker： 简单来说就是消息队列服务器实体
Exchange： 消息交换机，它指定消息按什么规则，路由到哪个队列
Queue： 消息队列载体，每个消息都会被投入到一个或多个队列
Binding： 绑定，它的作用就是把exchange和queue按照路由规则绑定起来
Routing Key： 路由关键字，exchange根据这个关键字进行消息投递
VHost： vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的
queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范
围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典
型的例子就是不同的应用可以跑在不同的 vhost 中）
Producer： 消息生产者，就是投递消息的程序
Consumer： 消息消费者，就是接受消息的程序
Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话
任务

简单模式：一个队列一个消费者；（没有交换机）
工作模式：一个队列多个消费者；（没有交换机）
发布订阅模式：多个队列多个消费者 （有交换机）
生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息
routing路由模式： 消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息;exChange的type=Direct：定向，把消息交给符合指定routing key 的队列
topic 主题模式：星号代表多个单词,井号代表一个单词，路由功能添加模糊匹配， 消息产生者产生消息,把消息交给交换机，交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费
#  如何保证RabbitMQ消息的顺序性
拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue
(消息队列)而已，确实是麻烦点；
或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内
部用内存队列做排队，然后分发给底层不同的 worker 来处理。
# 消息如何分发

# # 如何保证消息不被重复消费？或者说，如何保证消息消费时的幂等性？
先说为什么会重复消费：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消
息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除；但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。
针对以上问题，一个解决思路是：保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性；
比如：在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；
假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。
# 如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？
发送方确认模式
将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。
一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。
如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack otacknowledged，未确认）消息。
发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。
接收方确认机制
消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性；
下面罗列几种特殊情况
如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。(可能存在消息重复消费的隐患，需要去重);
如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不
会给该消费者分发更多的消息。
# 如何保证RabbitMQ消息的可靠传输？
消息不可靠的情况可能是消息丢失，劫持等原因；
丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；
# 生产者丢失消息
 从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息;
 transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；
 confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派
一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；
# 消息队列丢数据
 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。
 这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。
 这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。
 那么如何持久化呢？
 将queue的持久化标识durable设置为true,则代表是一个持久的队列
 发送消息的时候将deliveryMode=2,这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据
# 消费者丢失消息
消费者丢数据一般是因为采用了`自动确认消息模式`，改为手动确认消息即可！
消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；如果这时处理消息失败，就会丢失该消息；
解决方案：处理消息成功后，手动回复确认消息。

#  如何保证高可用的？RabbitMQ 的集群
RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。
 普通集群模式：你创建的 queue，`只会`放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据;
 你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。
 这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作;
 镜像集群模式:这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群
模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。
#  如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，怎么办？