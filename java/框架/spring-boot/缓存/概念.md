# spring-boot-starter-cache
缓存抽象的核心是将缓存应用于Java方法，从而根据缓存中可用的信息减少执行次数。也就是说，每次调用目标方法时，抽象都会应用缓存行为来检查是否已经为给定的参数调用了该方法。如果已经调用它，则返回缓存结果，而不必调用实际的方法。如果没有调用该方法，则调用该方法，并缓存结果并返回给用户，以便在下次调用该方法时返回缓存的结果。这样，对于给定的参数集，昂贵的方法(无论是CPU还是io绑定的)只能被调用一次，并且结果可以重用，而不必再次实际调用该方法。缓存逻辑是透明地应用的，不会对调用方产生任何干扰。

与Spring Framework中的其他服务一样，缓存服务是一种抽象(而不是缓存实现)，需要使用实际的存储来存储缓存数据——也就是说，抽象使您不必编写缓存逻辑，但不提供实际的数据存储。这种抽象是通过org.springframework.cache.Cache和org.springframework.cache.CacheManager接口具体化的。
缓存抽象对于多线程和多进程环境没有特殊的处理，因为这些特性是由缓存实现处理的。

缓存声明:确定需要缓存的方法及其策略。 
缓存配置:存储数据并从中读取数据的后备缓存。

# 声明性基于注释的缓存 
对于缓存声明，Spring的缓存抽象提供了一组Java注释: 
@Cacheable:触发缓存填充。 
@CacheEvict:触发缓存清除。 
@CachePut:在不干扰方法执行的情况下更新缓存。 
@Caching:将应用于一个方法的多个缓存操作重新分组。 
@CacheConfig:在类级别共享一些常见的缓存相关设置。