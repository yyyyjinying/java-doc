# 日志概述
日志文件是用于记录系统操作事件的文件集合，可分为`事件日志`和`消息日志`。具有处理历史数据、诊断问题的追踪以及理解系统的活动等重要作用
调试
在Java项目调试时，查看栈信息可以方便地知道当前程序的运行状态，输出的日志便于记录程序在之前的运行结果。如果你大量使用System.out或者System.err，这是一种最方便最有效的方法，但显得不够专业。
错误定位
System.err只能做到控制台打印日志
数据分析
ELK也让日志分析门槛降低了很多

# 日志实现（具体干活的
JUL（java util logging）、logback、log4j、log4j2是java原生的日志框架
Loggers：访问日志系统的入口程序；
Appenders： Logger会将日志交给关联 Handlers处理，由Handlers负责将日志做记录(ConsoleHandler,FileHandler等)。
Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。
Level：每条日志消息都有一个关联的日志级别
总结：
​ 用户使用Logger来进行日志记录，Logger持有若干个Handler，日志的输出操作是由Handler完成的。 在Handler在输出日志前，会经过Filter的过滤，判断哪些日志级别过滤放行哪些拦截，Handler会将日志内容输出到指定位置（日志文件、控制台等）。Handler在输出日志时会使用Layout，将输出内容进行排版。
# java.util.logging.Level中定义了日志的级别(7)：
SEVERE（最高值）
WARNING
INFO （默认级别）
CONFIG
FINE
FINER
FINEST（最低值）

OFF，可用来关闭日志记录。
ALL，启用所有消息的日志记录。
# 日志格式化

# 日志门面（指定规则的）
JCL（Jakarta Commons Logging）、slf4j（ Simple Logging Facade for Java）

# 常用的转换符
%s	字符串类型
%c	字符类型
%b	布尔类型
%d	整数类型（十进制）
%x	整数类型（十六进制
%o	整数类型（八进制）
%f	浮点类型
%a	十六进制浮点类型
%e	指数类型
%n	换行符
%tx	日期与时间类型
System.out.printf("过年了，%s今年%d岁了，今天收了%f元的压岁钱!",
                "小明",5,88.88);
过年了，小明今年5岁了，今天收了88.880000元的压岁钱!
# %tc
System.out.printf("%tc",new Date());
System.out.printf("%tc",ZonedDateTime.now());
System.out.printf("%tF",LocalDateTime.now());
c	包括全部日期和时间信息	周四 10月 21 14:52:10 GMT+08:00 2021
F	“年-月-日”格式	2021-10-21
D	“月/日/年”格式	10/21/21
r	“HH:MM:SS PM”格式（12时制）	02:53:20 下午
T	“HH:MM:SS”格式（24时制）	14:53:39
R	“HH:MM”格式（24时制）	14:53
b	月份本地化	10月
y	两位的年	21
Y	四位的年	2021
m	月	10
d	日	21
H	24小时制的时	14
l	12小时制的时	2
M	分	57
S	秒	46
s	秒为单位的时间戳	1634799527
p	上午还是下午	下午

Log4j是Apache下的一款开源的日志框架
log4j定义了以下的日志的级别(6)，和JUL的略有不同：
fatal 指出每个严重的错误事件将会导致应用程序的退出。
error 指出虽然发生错误事件，但仍然不影响系统的继续运行。
warn 表明会出现潜在的错误情形。
info 一般和在粗粒度级别上，强调应用程序的运行全程。
debug 一般用于细粒度级别上，对调试应用程序非常有帮助。
trace 是程序追踪，可以用于输出程序运行中的变量，显示执行的流程。
一般情况下，我们只使用4个级别，优先级从高到低为 ERROR > WARN > INFO > DEBUG。
Log4J 主要由 Loggers (日志记录器)、Appenders（输出端）和 Layout（日志格式化器）组成。其中 Loggers 控制日志的输出级别与日志是否输出；Appenders 指定日志的输出方式（输出到控制台、文件 等）；Layout 控制日志信息的输出格式。

# 日志门面
当我们的系统变的复杂的之后，难免会集成其他的系统，不同的系统之间可能会使用不同的日志系统。那么在一个系统中，我们的日志框架可能会出现多个，会出现混乱，而且随着时间的发展，可能会出现新的效率更高的日志系统，如果我们想切换代价会非常的大。如果我们的日志系统能和jdbc一样，有一套自己的规范，其他实现均按照规范去实现，就能很灵活的使用日志框架了。

​ 日志门面就是为了解决这个问题而出现的一种技术，日志门面是规范，其他的实现按照规范实现各自的日志框架即可，我们程序员基于日志门面编程即可。举个例子：日志门面就好比菜单，日志实现就好比厨师，我们去餐馆吃饭按照菜单点菜即可，厨师是谁其实不重要，但是有一个符合我口味的厨师当然会更好。

常见的日志门面： JCL、slf4j
常见的日志实现： JUL、log4j、logback、log4j2
日志框架出现的历史顺序：
log4j -->JUL-->JCL--> slf4j --> logback --> log4j2
最流行的日志门面SLF4J日志门面主要提供两大功能：
日志框架的绑定
日志框架的桥接
# 1、阿里日志规约
应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API。使用门面模式的日志框架，有利于维护和各个类的日志处理方法统一。
日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。
应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType为日志类型，推荐分类有stats/monitor/visit 等；
logName为日志描述。这种命名的好处：通过文件名就可以知道日志文件属于哪个应用，哪种类型，有什么目的，这也有利于归类查找。
对trace/debug/info级别的日志输出，必须使用条件输出形式或者占位符的方式。
避免重复打印日志，否则会浪费磁盘空间。务必在日志配置文件中设置additivity=false。
异常信息应该包括两类：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字向上抛出。
谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免吧服务器磁盘撑爆，并及时删除这些观察日志。
可以使用warn日志级别记录用户输入参数错误的情况，避免当用户投诉时无所适从。
# 使用slf4j的日志绑定:
添加slf4j-api的依赖
使用slf4j的API在项目中进行统一的日志记录
绑定具体的日志实现框架
# 桥接旧的日志框架（Bridging）
桥接解决的是项目中日志的遗留问题，当系统中存在之前的日志API，可以通过桥接转换到slf4j的实现

log4j-over-slf4j.jar和slf4j-log4j12.jar不能同时出现
jul-to-slf4j.jar和slf4j-jdk14.jar不能同时出现,前一个jar文件将导致JCL将日志系统的选择委托给 SLF4J，后一个jar文件将导致SLF4J将日志系统的选择委托给JCL，从而导致无限循环。
所有的桥接都只对Logger日志记录器对象有效，如果程序中调用了内部的配置类或者是 Appender,Filter等对象，将无法产生效果。
# 我们为什么要使用日志门面：
面向接口开发，不再依赖具体的实现类。减少代码的耦合
项目通过导入不同的日志实现类，可以灵活的切换日志框架
统一API，方便开发者学习和使用
统一配置便于项目日志的管理

# Log4j2入门
​目前已经有三个门面了，其实不管是哪里都是江湖，都想写一个门面，一统江湖，所以log42出了提供日志实现以外，也拥有一套自己的独立的门面。
​目前市面上最主流的日志门面就是SLF4J，虽然Log4j2也是日志门面，因为它的日志实现功能非常强大，性能优越。所以大家一般还是将Log4j2看作是日志的实现，Slf4j + Log4j2应该是未来的大势所趋。
