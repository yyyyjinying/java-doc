Netty为什么传输快?
Netty的传输快其实也是依赖了NIO的一个特性——零拷贝。我们知道，Java的内存有堆内存、栈内存和字符串常量池等等，其中堆内存是占用内存空间最大的一块，也是Java对象存放的地方，一般我们的数据如果需要从IO读取到堆内存，中间需要经过socket缓冲区，也就是说一个数据会被拷贝两次才能到达他的的终点，如果数据量大，就会造成不必要的资源浪费。
Netty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。
Netty和Tomcat有什么区别？
Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。

```dom
<dependency>
    <groupId>org.yeauty</groupId>
    <artifactId>netty-websocket-spring-boot-starter</artifactId>
    <version>0.12.0</version>
</dependency>
```
在端点类上加上@ServerEndpoint注解，并在相应的方法上加上@BeforeHandshake、@OnOpen、@OnClose、@OnError、@OnMessage、@OnBinary、@OnEvent注解，样例如下：
```java
package com.example.common.websocket;

import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.timeout.IdleStateEvent;
import org.springframework.util.MultiValueMap;
import org.yeauty.annotation.*;
import org.yeauty.pojo.Session;

import java.io.IOException;
import java.util.Map;

/**
 * Java 使用Websocket 与MQ消息队列实现即时消息
 * WebSocket + mq + redis(currentHashMap)
 * 使用策略模式： crrentHashMap + SpringUtil.getBean(Id, handler)
 * 使用枚举根据不同的的状态参数，对应不同的handler的处理器名称，然后通过SpringUtil.getBean(Id, handler)获取到准备好的处理器单例对象，执行不同的处理器对象，不同的处理器对象中可能，执行mq异步消息推送，因为mq中有很多消息，但每条消息具体到哪个用户发送的使用sessionID来区分，当异步消费时，通过sessionID去匹配对应的Session对象给对应的用户返回结果，执行session.sendText(“处理后返回的消息”), （返回不同的结果集；结果集也进行了统一的封装)；
 * 所以，ssessionid和Session对象，在webSocket执行onMessage(Session session, String message)方法时，就保存到redis或者currentHashMap中，在异步消费的时候获取到Session对象，返回给指定用户；
 */
@ServerEndpoint(host = "${ws.host}", port = "${ws.port.first}", path = "/myWs")
public class MyWebSocket {

    @BeforeHandshake
    public void handshake(Session session,
                          HttpHeaders headers,
                          @RequestParam String req,
                          @RequestParam MultiValueMap reqMap,
                          @PathVariable String arg,
                          @PathVariable Map pathMap){
        System.out.println("000000");
        System.out.println(session);
        System.out.println(headers);
        System.out.println(req);
        System.out.println(reqMap);
        System.out.println(arg);
        System.out.println(pathMap);
        System.out.println("000000");
//        session.setSubprotocols("stomp");
//        if (!"ok".equals(req)){
//            System.out.println("Authentication failed!");
//            session.close();
//        }
    }

    @OnOpen
    public void onOpen(Session session, HttpHeaders headers, @RequestParam String req, @RequestParam MultiValueMap reqMap, @PathVariable String arg, @PathVariable Map pathMap){
        System.out.println("new connection");
        System.out.println(req);
    }

    @OnClose
    public void onClose(Session session) throws IOException {
        System.out.println("one connection closed");
    }

    @OnError
    public void onError(Session session, Throwable throwable) {
        throwable.printStackTrace();
    }

    @OnMessage
    public void onMessage(Session session, String message) {
        System.out.println("first接受的客户端发送消息" + message);
        session.sendText("first服务端发送给客户端的消息--Hello Netty!");

    }

    @OnBinary
    public void onBinary(Session session, byte[] bytes) {
        for (byte b : bytes) {
            System.out.println(b);
        }
        session.sendBinary(bytes);
    }

    @OnEvent
    public void onEvent(Session session, Object evt) {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent idleStateEvent = (IdleStateEvent) evt;
            switch (idleStateEvent.state()) {
                case READER_IDLE:
                    System.out.println("read idle");
                    break;
                case WRITER_IDLE:
                    System.out.println("write idle");
                    break;
                case ALL_IDLE:
                    System.out.println("all idle");
                    break;
                default:
                    break;
            }
        }
    }
}
```
Websocket使用 ws 或 wss 的统一资源标志符，类似于 HTTP 或 HTTPS
ws = new WebSocket("ws://localhost:8384/myWs");

ws 协议使用 80 端口；运行在TLS之上时，wss 协议默认使用 443 端口。其实说白了，wss 就是 ws 基于 SSL 的安全传输，与 HTTPS 一样样的道理。
如果你的网站是 HTTPS 协议的，那你就不能使用 ws:// 了,浏览器会 block 掉连接，和 HTTPS 下不允许 HTTP 请求一样;

/**
 * 使用tomcat启动无需配置
 */
//@Configuration
//@ConditionalOnProperty(name="websocket.enabled",havingValue = "true")
public class WebSocketConfig {
    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }
}


基于springboot环境搭建的websocket+rabbitmq，搭建完成后发现websocket每隔一段时间会断开，看网上有人因为nginx的连接超时机制断开，而我这似乎是因为长连接空闲时间太长而断开
经过测试，如果一直保持每隔段时间发送消息，那么连接不会断开，所以我采用了断开重连机制，分三种情况
服务器正常，客户端正常且空闲时间不超过1分钟，则情况正常，超过一分钟会断线，前端发起请求重连
服务器正常，客户端关闭或注销，服务器正常收到通知，去除对应客户端session
服务器异常，客户端正常，客户端发现连不上服务器会尝试重连3次，3次都连不上放弃重连
rabbitmq定向推送，按需求需要一台机器对应一批用户，所以定制化需要服务启动的时候定向订阅该ip对应的队列名，简单说就是动态队列名的设定，所以又复杂了点，不能直接在注解写死。同时因为使用的apollo配置中心，同一集群应该相同的配置，所以也不能通过提取配置的方式设定值，为了这个点设置apollo的集群方式有点小题大做，所以采用动态读取数据库对应的ip取出对应的队列名。

# 心跳机制：
在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线。

二、工作原理
在 client 与 server 之间在一定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性。

TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：SO_KEEPALIVE。但是，TCP 协议层面的长连接灵活性不够。所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 IdleStateHandler 。
readerIdleTimeSeconds: 读超时. 即当在指定的时间间隔内没有从 Channel 读取到数据时, 会触发一个 READER_IDLE 的 IdleStateEvent 事件.
writerIdleTimeSeconds: 写超时. 即当在指定的时间间隔内没有数据写入到 Channel 时, 会触发一个 WRITER_IDLE 的 IdleStateEvent 事件.
allIdleTimeSeconds: 读/写超时. 即当在指定的时间间隔内没有读或写操作时