Reactor线程模型
# Netty和Tomcat有什么区别？
Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过`编程自定义各种协议`，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。
有人说netty的性能就一定比tomcat性能高，其实不然，tomcat从6.x开始就支持了nio模式，并且后续还有APR模式——一种通过jni调用apache网络库的模式，相比于旧的bio模式，并发性能得到了很大提高，特别是APR模式，而netty是否比tomcat性能更高，则要取决于netty程序作者的技术实力了。
# 为什么Netty受欢迎？
## 一、并发高
Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高;
# 为什么单线程能处理更多的连接呢？原因就是图二中出现的Selector
当一个连接建立之后，他有两个步骤要做，第一步是接收完客户端发过来的全部数据，第二步是服务端处理完请求业务之后返回response给客户端。NIO和BIO的区别主要是在第一步。
在BIO中，等待客户端发数据这个过程是阻塞的，这样就造成了一个线程只能处理一个请求的情况，而机器能支持的最大线程数是有限的，这就是为什么BIO不能支持高并发的原因。
而NIO中，当一个Socket建立好之后，Thread并不会阻塞去接受这个Socket，而是将这个请求交给Selector，Selector会不断的去遍历所有的Socket，一旦有一个Socket建立完成，他会通知Thread，然后Thread处理完数据再返回给客户端——这个过程是不阻塞的，这样就能让一个Thread处理更多的请求了。
# 
BIO，同步阻塞IO，阻塞整个步骤，如果连接少，他的延迟是最低的，因为一个线程只处理一个连接，适用于少连接且延迟低的场景，比如说数据库连接。
NIO，同步非阻塞IO，阻塞业务处理但不阻塞数据接收，适用于高并发且处理简单的场景，比如聊天软件。
多路复用IO，他的两个步骤处理是分开的，也就是说，一个连接可能他的数据接收是线程a完成的，数据处理是线程b完成的，他比BIO能处理更多请求。
异步IO，他的数据请求和数据处理都是异步的，数据请求一次返回一次，适用于长连接的业务场景。
# 二、传输快
Netty的传输快其实也是依赖了NIO的一个特性——零拷贝。我们知道，Java的内存有堆内存、栈内存和字符串常量池等等，其中堆内存是占用内存空间最大的一块，也是Java对象存放的地方，一般我们的数据如果需要从IO读取到堆内存，中间需要经过Socket缓冲区，也就是说一个数据会被拷贝两次才能到达他的的终点，如果数据量大，就会造成不必要的资源浪费。Netty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。
# 三、封装好
Channel，表示一个连接，可以理解为每一个请求，就是一个Channel。
ChannelHandler，核心处理业务就在这里，用于处理业务请求。
ChannelHandlerContext，用于传输业务数据。
ChannelPipeline，用于保存处理过程需要用到的ChannelHandler和ChannelHandlerContext。
# ByteBuf
ByteBuf是一个存储字节的容器，最大特点就是使用方便，它既有自己的读索引和写索引，方便你对整段字节缓存进行读写，也支持get/set，方便你对其中每一个字节进行读写；
三种使用模式：
Heap Buffer 堆缓冲区：堆缓冲区是ByteBuf最常用的模式，他将数据存储在堆空间。
Direct Buffer 直接缓冲区：直接缓冲区是ByteBuf的另外一种常用模式，他的内存分配都不发生在堆，jdk1.4引入的nio的ByteBuffer类允许jvm通过本地方法调用分配内存，这样做有两个好处；
通过免去中间交换的内存拷贝, 提升IO处理速度; 直接缓冲区的内容可以驻留在垃圾回收扫描的堆区以外;
DirectBuffer 在 -XX:MaxDirectMemorySize=xxM大小限制下, 使用 Heap 之外的内存, GC对此”无能为力”,也就意味着规避了在高负载下频繁的GC过程对应用线程的中断影响;
Composite Buffer 复合缓冲区:复合缓冲区相当于多个不同ByteBuf的视图，这是netty提供的，jdk不提供这样的功能。
# Codec
Netty中的编码/解码器，通过他你能完成字节与pojo、pojo与pojo的相互转换，从而达到自定义协议的目的;

# BIO的实现
服务端：new ServerSocket()对象（bind监听端口），调用accept = serverSocket.accept()；来监听连接（套接字的连接）并阻塞；一个线程只能处理一个请求；accept接收客户端发送过来的数据（输入流写入数据）；
客户端：socket = new Socket()；使用connect方法发送连接，socket.connect(inetSocketAddress)；而在socket写入需要发送给服务器的数据（输出流写出数据）；
为了实现多个并行的客户端我们需要分配一个新的 Thread 给每个新的客户端 Socket(当然需要更多的代码)。但考虑使用这种方法来支持大量的同步，长连接。在任何时间点多线程可能处于休眠状态，等待输入或输出数据。每个线程都有一个默认的堆栈内存分配了 128K 和 1M 之间的空间,这很容易使得资源的大量浪费;
# NIO的实现
selector绑定多个Channel检测是否有事件发生，如果有就处理，不需要为每个连接创建线程；核心api有Selector\SelectionKey\Buffers
# Selector
Selector能够检测多个注册的通道上是否有事件发生(注意:多个Channel以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件，然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。
# NIO api的核心抽象
Buffers：缓冲区，是数据的容器; position:下一个要读或写的元素的索引; limit：第一个不应该读或写的元素的索引； clearing, flipping, and rewinding, for marking the current position, and for resetting the position to the previous mark（清除、翻转和倒回、标记当前位置以及将位置重置为前一个标记的方法）compacting, duplicating, and slicing a buffer,allocating a new buffer, wrapping an existing array(压缩，复制，分片，分配，数组包装),

Charsets and their associated decoders and encoders,
which translate between bytes and Unicode characters;字符集及其相关的解码器和编码器，在字节和Unicode字符之间转换;
各种类型的通道(Channels)：它们表示连接`能够执行I/O操作的实体`;
选择器和选择键(Selectors and selection keys):与可选通道一起定义了多路复用、非阻塞I/O设备。
java.nio包定义了在整个nio api中使用的缓冲类。字符集API定义在java.nio.charset包中, channel和selector API定义在java.nio.channels包中。这些子包中的每一个子包都有自己的服务提供者(SPI)子包，其中的内容可用于扩展平台的默认实现或构造替代实现。
SelectableChannel：
可以通过选择器进行多路复用的通道。为了与选择器一起使用，该类的实例必须首先通过register方法注册。该方法返回一个新的SelectionKey对象，该对象表示频道与选择器的注册。 一旦向选择器注册，通道将保持注册状态，直到取消注册。这涉及到释放选择器分配给通道的任何资源。不能直接注销通道;相反，必须取消代表其注册的键。取消键要求在选择器的下一个选择操作期间注销通道。可以通过调用键的cancel方法显式地取消键。当通道关闭时，通道的所有键都将隐式取消，无论是通过调用其close方法，还是通过中断在通道上的I/O操作中阻塞的线程。如果选择器本身被关闭，那么通道将被取消注册，表示其注册的键将无效，不再有进一步的延迟。 一个通道最多只能向任何特定的选择器注册一次。 通道是否向一个或多个选择器注册可以通过调用isRegistered方法来确定。 可选通道对于多个并发线程使用是安全的。

Selector：
选择器可以通过调用该类的open方法来创建，该方法将使用系统的默认选择器提供程序来创建一个新的选择器。还可以通过调用自定义选择器提供程序的openSelector方法来创建选择器。选择器一直保持打开状态，直到通过close方法关闭为止。 可选择通道在选择器上的注册由SelectionKey对象表示；

SelectionKey: 表示SelectableChannel注册到选择器的标记。
每次向选择器注册通道时，都会创建一个选择键。一个键在通过调用它的cancel方法、关闭它的通道或关闭它的选择器来取消它之前一直有效。取消一个键不会立即将其从选择器中移除;相反，它被添加到选择器的取消键集中，以便在下一个选择操作期间删除。一个键的有效性可以通过调用它的isValid方法来测试。 一个选择键包含两个用整数值表示的操作集。操作集的每一位表示键的通道支持的可选操作的类别。兴趣集决定在下次调用选择器的选择方法时测试哪些操作类别是否就绪。兴趣集在创建键时使用给定的值进行初始化;稍后可以通过interestOps(int)方法进行更改。就绪集标识由密钥选择器检测到密钥的通道已就绪的操作类别。创建键时，就绪集初始化为零;它可以稍后由选择器在选择操作期间更新，但不能直接更新
channel().返回为其创建此键的通道


# EventLoop
事件循环对象
EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。
继承：
一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法；
一条线是继承自 netty 自己的 OrderedEventExecutor（哪个 EventLoopGroup）
* 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop
* 提供了 parent 方法来看看自己属于哪个 EventLoopGroup

# EventLoopGroup 
是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）

#### 优雅关闭
优雅关闭 `shutdownGracefully` 方法。该方法会首先切换 `EventLoopGroup` 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的

### 异步提升
单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势；
异步并没有缩短响应时间，反而有所增加；
合理进行任务拆分，也是利用异步的关键；
增加了吞吐量；

### Future & Promise
jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果
netty Future 可以`同步等待任务`结束得到结果，也可以`异步方式`得到结果，但都是要等任务结束
netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器

### EventLoopGroup
EventLoopGroup有多个EventLoop，而EventLoop只有一个线程；
### ### Handler & Pipeline
ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline
* 入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果
* 出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工
打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品

# byteBuf
读指针和写指针
nio的byteBuffer共用一个指针

