# 简介
- 优秀的持久层框架，支持自定义 SQL、存储过程以及高级映射
- 包括SQL Maps和Data Access Objects（DAO）

# MyBatis特性
- MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架
- MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集
- MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录
- MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架

# 对比
### JDBC
SQL 夹杂在Java代码中耦合度高，导致硬编码内伤
维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见
代码冗长，开发效率低
### Hibernate 和 JPA
操作简便，开发效率高
程序中的长难复杂 SQL 需要绕过框架
内部自动生产的 SQL，不容易做特殊优化
基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难
反射操作太多，导致数据库性能下降

# MyBatis的映射文件
对象关系映射
- 对象：Java的实体类对象
- 关系：关系型数据库
- 映射：二者之间的对应关系

### 映射文件的命名规则
表所对应的实体类的类名+Mapper.xml
一个映射文件对应一个实体类，对应一张表的操作
MyBatis映射文件用于编写SQL，访问以及操作表中的数据
MyBatis映射文件存放的位置是src/main/resources/mappers目录下
### MyBatis中可以面向接口操作数据
- mapper接口的全类名和映射文件的命名空间（namespace）保持一致
- mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致


SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）
SqlSessionFactory：是“生产”SqlSession的“工厂”
```java
public void testInsertUser() throws IOException {
    //读取MyBatis的核心配置文件
    InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
    //获取SqlSessionFactoryBuilder对象
    SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
    //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象
    SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
    //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务
    //SqlSession sqlSession = sqlSessionFactory.openSession();
    //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  
    SqlSession sqlSession = sqlSessionFactory.openSession(true);
    //通过代理模式创建UserMapper接口的代理实现类对象
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句
    int result = userMapper.insertUser();
    //提交事务
    //sqlSession.commit();
    System.out.println("result:" + result);
}
```

## MyBatis获取参数值的两种方式（重点）
${}的本质就是字符串拼接，#{}的本质就是占位符赋值
${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号
```xml
<!--单个字面量类型的参数: User checkLogin(String username);-->
<select id="getUserByUsername" resultType="User">  
	select * from t_user where username = '${username}'  
</select>
<!--多个字面量类型的参数: User checkLogin(String username,String password);-->
<select id="checkLogin" resultType="User">
	select * from t_user where username = '${param1}' and password = '${param2}'
</select>
<!--map集合类型的参数: User checkLoginByMap(Map<String,Object> map);-->
<select id="checkLoginByMap" resultType="User">
	select * from t_user where username = #{username} and password = #{password}
</select>
<!-- 实体类类型的参数: int insertUser(User user);-->
<insert id="insertUser">
	insert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})
</insert>

<!--User CheckLoginByParam(@Param("username") String username, @Param("password") String password);-->
<select id="CheckLoginByParam" resultType="User">
    select * from t_user where username = #{username} and password = #{password}
</select>

<!--查询单个数据 int getCount();-->
<select id="getCount" resultType="_integer">
	select count(id) from t_user
</select>

<!--查询一个实体类对象 User getUserById(@Param("id") int id);-->
<select id="getUserById" resultType="User">
	select * from t_user where id = #{id}
</select>

<!--查询一个List集合 List<User> getUserList();-->
<select id="getUserList" resultType="User">
	select * from t_user
</select>

<!--Map<String, Object> getUserToMap(@Param("id") int id);-->
<select id="getUserToMap" resultType="map">
	select * from t_user where id = #{id}
</select>
<!--结果：{password=123456, sex=男, id=1, age=23, username=admin}-->

<!-- List<Map<String, Object>> getAllUserToMap(); -->
<select id="getAllUserToMap" resultType="map">  
	select * from t_user  
</select>
<!--
	结果：
	[{password=123456, sex=男, id=1, age=23, username=admin},
	{password=123456, sex=男, id=2, age=23, username=张三},
	{password=123456, sex=男, id=3, age=23, username=张三}]
-->
<!--List<User> findbyNameParam(@Param("name") String name, @Param("phone") String phone);-->
<select id="findbyNameParam" resultType="com.example.netty.domain.pojo.User">
select * from tb_user where name=#{name} or phone=#{phone}
</select>
<!--Map<String, Object> findMapByNameParam(@Param("name") String name);-->
<select id="findMapByNameParam" resultType="map">
select * from tb_user where name=#{name}
</select>
<!--List<Map<String, Object>> findMapByNameAndPhoneParams(@Param("name") String name, @Param("phone") String phone);-->
<select id="findMapByNameAndPhoneParams" resultType="map">
select * from tb_user where name='${name}' or phone='${phone}'
</select>
<!-- 
    @MapKey("id")
    Map<String, Object> getAllUserToMap();
 -->
<select id="getAllUserToMap" resultType="map">  
	select * from t_user  
</select>
<!--
	结果：
	[{password=123456, sex=男, id=1, age=23, username=admin},
	{password=123456, sex=男, id=2, age=23, username=张三},
	{password=123456, sex=男, id=3, age=23, username=张三}]
-->

<!--模糊查询 List<User> getUserByLike(@Param("username") String username);-->
<select id="getUserByLike" resultType="User">
	<!--select * from t_user where username like '%${mohu}%'-->  
	<!--select * from t_user where username like concat('%',#{mohu},'%')-->  
	select * from t_user where username like "%"#{mohu}"%"
</select>
<!--根据id批量删除 int deleteMore(@Param("ids") String ids); -->
<delete id="deleteMore">
<!-- mapper.deleteMore("1,2,3,8"); -->
	delete from t_user where id in (${ids})
</delete>

<!--动态设置表名 List<User> getUserByTable(@Param("tableName") String tableName); -->
<select id="getUserByTable" resultType="User">
	select * from ${tableName}
</select>

<!--void insertUser(User user);-->
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id">
<!-- User user = new User(null, "ton", "123", 23, "男", "123@321.com");
	mapper.insertUser(user); -->
	insert into t_user values (null,#{username},#{password},#{age},#{sex},#{email})
</insert>
<!-- 输出：user{id=10, username='ton', password='123', age=23, sex='男', email='123@321.com'}，自增主键存放到了user的id属性中 -->

<!-- 通过为字段起别名的方式，保证和实体类中的属性名保持一致 -->
<!--List<Emp> getAllEmp();-->
<select id="getAllEmp" resultType="Emp">
	select eid,emp_name empName,age,sex,email from t_emp
</select>

<!-- resultMap处理字段和属性的映射关系 -->
<resultMap id="empResultMap" type="Emp">
	<id property="eid" column="eid"></id>
	<result property="empName" column="emp_name"></result>
	<result property="age" column="age"></result>
	<result property="sex" column="sex"></result>
	<result property="email" column="email"></result>
</resultMap>
<!--List<Emp> getAllEmp();-->
<select id="getAllEmp" resultMap="empResultMap">
	select * from t_emp
</select>
```
# 传递的参数
@Select("select * from user where ${column} = #{value}")
User findByColumn(@Param("column") String column, @Param("value") String value);
`${column} 会被直接替换，而 #{value} 会使用 ? 预处理`

2、所传参数为数组
List<FshEstate> getEstateByEstateId(String[] estateIds);
<select id="getEstateByEstateId" parameterType="java.util.List" resultType="com.model.mpublic.FshEstate">
        SELECT *
        FROM fsh_estate est
        WHERE est.estate_id in
        <foreach collection="array" item="estateId" index="index"
                 open="(" close=")" separator=",">
            #{estateId}
        </foreach>
</select>

void disableUsers(@Param("userIds") List<Integer> userIds,@Param("disable") String disable);
xml:
<update id="disableUsers">
    UPDATE t_user
    SET disable_flag = #{disable}
    WHERE 1 = 1
    <if test="userIds != null and userIds.size > 0">
        AND id IN
        <foreach collection="userIds" item="item" open="(" separator="," close=")">
            #{item}
        </foreach>
    </if>
</update>

# 动态sql
```xml
<!-- 自动添加where关键字以及自动删除多余的and/or -->
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
    select * from t_emp
    <where>
        <if test="empName != null and empName !=''">
            emp_name = #{empName}
        </if>
        <if test="age != null and age !=''">
            and age = #{age}
        </if>
        <if test="sex != null and sex !=''">
            and sex = #{sex}
        </if>
        <if test="email != null and email !=''">
            and email = #{email}
        </if>
    </where>
</select>
```
# trim用于去掉或添加标签中的内容
常用属性
- prefix：在trim标签中的内容的前面添加某些内容
- suffix：在trim标签中的内容的后面添加某些内容
- prefixOverrides：在trim标签中的内容的前面去掉某些内容
- suffixOverrides：在trim标签中的内容的后面去掉某些内容

```xml
<!--int deleteMoreByArray(Integer[] eids);-->
<delete id="deleteMoreByArray">
	delete from t_emp where eid in
	<foreach collection="eids" item="eid" separator="," open="(" close=")">
		#{eid}
	</foreach>
</delete>
<!--
    Emp emp1 = new Emp(null,"a",1,"男","123@321.com",null);
	Emp emp2 = new Emp(null,"b",1,"男","123@321.com",null);
	Emp emp3 = new Emp(null,"c",1,"男","123@321.com",null);
	List<Emp> emps = Arrays.asList(emp1, emp2, emp3);
	int result = mapper.insertMoreByList(emps);
 -->
<!--int insertMoreByList(@Param("emps") List<Emp> emps);-->
<insert id="insertMoreByList">
	insert into t_emp values
	<foreach collection="emps" item="emp" separator=",">
		(null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email},null)
	</foreach>
</insert>
```

# sql片段
```xml
<sql id="empColumns">eid,emp_name,age,sex,email</sql>
<!--List<Emp> getEmpByCondition(Emp emp);-->
<select id="getEmpByCondition" resultType="Emp">
	select <include refid="empColumns"></include> from t_emp
</select>

<!-- 参数为map集合 List<User> findMapByMapParams(@Param("params") Map<String, String> params); -->
<select id="findMapByMapParams" resultType="com.example.netty.domain.pojo.User">
    select * from tb_user
    <where>
        <if test="params.name != null and params.name != ''">
        name = '${params.name}'
        </if>
        <if test="params.phone != null and params.phone != ''">
        or phone = '${params.phone}'
        </if>
    </where>
</select>
```
# select
resultType	期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。
resultMap	对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。

# MyBatis的一级缓存
一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问
一级缓存失效的四种情况:
- 不同的SqlSession对应不同的一级缓存
- 同一个SqlSession但是查询条件不同
- 同一个SqlSession两次查询期间执行了任何一次增删改操作
- 同一个SqlSession两次查询期间手动清空了缓存

# MyBatis的二级缓存
二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取

二级缓存开启
- 设置全局配置属性cacheEnabled=“true”，默认为true，不需要设置
- 在映射文件中设置标签
- 二级缓存必须在SqlSession关闭或提交之后有效
- 查询的数据所转换的实体类类型必须`实现序列化的接口`
- 使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效

# MyBatis缓存查询的顺序
先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用
如果二级缓存没有命中，再查询一级缓存
如果一级缓存也没有命中，则查询数据库
SqlSession关闭之后，一级缓存中的数据会写入二级缓存

# java狭义一些的缓存，主要是指三大类
- 虚拟机缓存（ehcache，JBoss Cache）
- 分布式缓存（redis，memcache）
- 数据库缓存
速度由上到下依次减慢

# 为什么要用缓存？
一个高并发项目来说，一秒钟服务器收到的请求是非常多的，而如果这每一次的请求都直接请求数据库服务器，那么数据库的压力将会变得非常大。
传统数据库架构，能同时承受的高并发数量是有限的

# 如何再不改动原数据库的情况下，降低并发压力
- 数据库集群
- 消息队列（削峰）
- 数据缓存

数据库集群是从提高数据库承受能力的角度去做提升
消息队列是用削峰的方式去降低同一时刻的并发压力
数据缓存则是从程序上降低请求访问数据库的量

# 分布式缓存和虚拟机缓存
两者的区别（拿ehcache和redis举例）
1.应用场景的不同，虚拟机用在单体应用，分布式缓存不仅可以用在单体应用，也可以用于分布式缓存，自带分布式锁保证数据一致性。
2.数据储存位置不同，ehcache储存在虚拟机堆内存中，redis储存在内存中（数据库储存在硬盘中）从硬件特性上也可以很好看出他们的速度差别。

造成的影响不同，ehcache储存在堆内存会在一定程度上影响系统性能，而redis是可以搭建redis服务器的，让缓存系统独立出来。

# 缓存的淘汰策略
LRU（Least Recently Used）最近最久未使用的
LFU（Least Frequently Used）最近最少使用算法
FIFO（First in First out）先进先出

# 缓存的更新策略具体有哪些
- Cache Aside模式
应用在查询数据的时候，先从缓存Cache中读取数据，如果缓存中没有，则再从数据库中读取数据，得到数据库的数据之后，将这个数据也放到缓存Cache中。
如果应用要更新某个数据，也是先去更新数据库中的数据，更新完成之后，则通过指令让缓存Cache中的数据失效。
- Read/Write Through 模式
应用要读数据和更新数据都直接访问缓存服务
缓存服务同步的将数据更新到数据库
- Write Behind 模式
应用要读数据和更新数据都直接访问缓存服务
缓存服务异步的将数据更新到数据库（通过异步任务）

# 缓存会出现的一些问题
缓存穿透：缓存中没有该数据，数据库也没有该数据，但是请求过来的时候，还是要用数据库语句进行查询，这就是缓存击穿。攻击者可能对这一个不存在的数据反复的进行查询请求，对数据库造成极大压力。
解决方式：对没有的值也加入缓存，比如key-null，设置过期时间，避免这一段时间内重复对该值进行反复请求；接口层增加鉴定，不符合要求的直接返回，不进入数据库查询队列。

缓存击穿：缓存中没有该数据，数据库有该数据，但是同时来了一堆请求查询到缓存没有数据，会在一瞬间加重数据库压力
解决方式：添加互斥锁（取数据串行化）；设置热点数据永不过期；

缓存雪崩：大量缓存中的key在同一时间过期
解决方式：设置热点数据永不过期，缓存预热

1.缓存的过期时间问题：
设计缓存的过期时间需要非常的有技巧，且必须与业务实际情况相结合。因为如果设计的过期时间太短了，那会导致缓存效果不佳，且还会造成频繁的从数据库中往缓存里写数据。如果缓存设计的过期时间太长了，又会导致内存的浪费。

2.缓存的命中率问题：
这也是设计缓存中需要存放哪些数据的很重要一点，如果设计的不好，可能会导致缓存命中率过低，失去缓存效果。一般对于热点数据而言，要保证命中率达到70%以上效果最佳。

3.缓存的穿透/雪崩问题：
是指如果缓存服务一旦宕机或全部丢失，那么有可能一瞬间所有的流量都直接打到了后端数据库上，可能会造成连锁反应，瞬间的请求高峰极有可能导致数据库无法承载。

# join 连表查询语句
namespace -> mapper接口
resultMap.type -> javaBean对象
result.property -> javaBean对象属性
result.column -> sql语句的返回的字段名

```xml
<mapper namespace="com.example.netty.dao.DeptManagerMapper">
    <resultMap id="dmsResultMap" type="com.example.netty.domain.BO.MdEmpSalaries">
        <result property="empNo" column="emp_no"/>
        <result property="deptNo" column="dept_no"/>
        <result property="salary" column="salary"/>
    </resultMap>

    <select id="findList" resultMap="dmsResultMap">
        select d.dept_no as dept_no,d.emp_no as emp_no,s.salary as salary from employees y join salaries s on y.emp_no=s.emp_no join dept_emp d on y.emp_no=d.emp_no join dept_manager m on d.dept_no=m.dept_no and d.emp_no != m.emp_no
    </select>

<!-- 

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    @Accessors(chain = true)
    public class MdEmpSalaries {
        private Integer empNo;
        private String deptNo;
        private Integer salary;

    }
 -->
    <select id="findList" resultType="com.example.netty.domain.BO.MdEmpSalaries">
        select d.dept_no as deptNo, d.emp_no as empNo, s.salary as salary from employees y join salaries s on y.emp_no=s.emp_no join dept_emp d on y.emp_no=d.emp_no join dept_manager m on d.dept_no=m.dept_no and d.emp_no != m.emp_no
    </select>
</mapper>
```