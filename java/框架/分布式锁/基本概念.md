# 锁的分类
1.乐观锁与悲观锁
乐观锁
悲观锁
2 、可重⼊锁和⾮可重⼊锁
可重⼊锁：当在⼀个线程中第⼀次成功获取锁之后，在此线程中就可以再次获取
⾮可重⼊锁
2 、可重⼊锁和⾮可重⼊锁
可重⼊锁：当在⼀个线程中第⼀次成功获取锁之后，在此线程中就可以再次获取
⾮可重⼊锁
4 、阻塞锁和⾮阻塞锁
阻塞锁：不断尝试获取锁，直到获取到锁为⽌
⾮阻塞锁：如果获取不到锁就放弃，但可以⽀持在⼀定时间段内的重试,在⼀段时间内如果没有获取到锁就放弃
# 分布式锁特点
1 、互斥性
和我们本地锁⼀样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。
2 、可重⼊性
同⼀个节点上的同⼀个线程如果获取了锁之后那么也可以再次获取这个锁。
3 、锁超时
和本地锁⼀样⽀持锁超时，加锁成功之后设置超时时间，以防⽌线程故障导致不释放锁，防
⽌死锁。
4 、⾼效，⾼可⽤
加锁和解锁需要⾼效，同时也需要保证⾼可⽤防⽌分布式锁失效，可以增加降级。



{

​      title: '商户名称',

​      dataIndex: 'merName',

​      key: 'merName',

​      width: 150,

​      render: text => <span>{text}</span>

​    },



const [searchFormData, setSearchFormData] = useState([

​    { key: 'createTimeStart', type: 'date', name: '创建时间（起）' },

​    { key: 'createTimeEnd', type: 'date', name: '创建时间（止）' },

​    { key: 'name', type: 'input', name: '姓名' },

​    { key: 'idCard', type: 'input', name: '身份证号码' },

​    { key: 'signingState', type: 'select', name: '签约状态', optionList: [] },

​    { key: 'levyId', type: 'select', name: '商户名', optionList: [] },

  ]);



useEffect(() => {

​    const { actionPromise } = props.getDictionaryList({ type: 'INVOICE_STATE' });

​    actionPromise.then(res => {

​      formSearchFormData(res, searchFormData, 'state', setSearchFormData);

​    })



​    const { actionPromise: list } = props.getNameMerchantSelect();

​    list.then(res => {

​      if (res.code == 200) {

​        res.data = res.data.map(item => ({ value: item.id, label: item.name }));

​        formSearchFormData(res, searchFormData, 'merId', setSearchFormData);

​      }

​    })

  }, []);



const [searchFormData, setSearchFormData] = useState([

​    { key: 'createTimeStart', type: 'date', name: '申请日期（起）' },

​    { key: 'createTimeEnd', type: 'date', name: '申请日期（止）' },

​    { key: 'state', type: 'select', name: '开票状态', optionList: [] },

​    { key: 'merId', type: 'select', name: '商户名称', optionList: [] },

  ]);

import { getNameMerchantSelect } from 'routes/MerchantCenter/Professional/SignRecord/reducer';

export default connect(state => ({

  invoiceList: state.invoiceInquiry.invoiceList,

  total: state.invoiceInquiry.total,

  amountInfo: state.invoiceInquiry.amountInfo,

}), {

  getInvoiceList,

  getDictionaryList,

  getNameMerchantSelect,

  getStatisticAmount,

  exportMerInvoice

})(InvoiceInquiry);