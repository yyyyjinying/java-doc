文件路径: 正斜杠，又称左斜杠，符号是"/"；反斜杠，也称右斜杠，符号是"\" 
在Java当中反斜杠代表的是转义:
制表符（也叫制表位）的功能是在不使用表格的情况下在垂直方向按列对齐文本，就是咱们的Tab键。\" 将双引号转义为真正的双引号;‘\r’ (回车)：即将光标回到当前行的`行首`(而不会换到下一行)，之后的输出会把之前的输出覆盖
‘\n’ 换行，换到当前位置的`下一位置`，而不会回到行首
File类表示处理文件和文件系统的相关信息,不具有从文件读取信息和向文件写入信息的功能，它仅描述文件本身的属性.
创建文件夹：mkdir()， mkdirs()多级
创建文件： createNewFile()	
delete(): 删除文件或者删除单级文件夹
exists(),isAbsolute()绝对路径判断；isDirectory()目录是否存在；isFile()是否文件；isHidden()是否是是一隐藏文件
```java
public static File[] hasJpg(File file){
    return file.listFiles(new FilenameFilter() {
        @Override
        public boolean accept(File dir, String name) {
            if (dir.isHidden() || name.contains(".DS_Store")) {
                return false;
            }
            return dir.isDirectory() || name.contains(".jpg");
        }
    });
}
public static void printJpg(File file){
    File[] files = ListAllPng.hasJpg(file);
    for (File item : files) {
        if (item.isDirectory()) {
            printJpg(item);
        } else {
            System.out.println(item.getAbsolutePath());
        }
    }
}
```
按照流向分：输入流、输出流；
按照操作单元划分：字节流：是一个字节一个字节的读取或写入；字符流：是一个字符一个字符的读取或写入，一个字符就是两个字节，主要用来处理字符。
按照角色划分： 节点流：直接从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，称为节点流；处理流：“连接”在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能的流；
```java
public static void demo04() {
        try(
            FileInputStream is = new FileInputStream(patha);
            FileOutputStream os = new FileOutputStream(pathb, true);
        ) {
            int len = 0;
            byte[] byt = new byte[4];
            while ((len = is.read(byt)) != -1){
                os.write(byt, 0, len);
            }

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```
# 字符流
```java
public static void demo2(){

        try {
            FileReader fr = new FileReader(patha);
            FileWriter fw = new FileWriter(pathb);

            int read = 0;
            char[] cr = new char[3];
            while ((read = fr.read(cr)) != -1) {

                fw.write(cr, 0, read);
            }

            fw.close();
            fr.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
```
# 序列化和反序列化
序列化：将对象写入到IO流中，说的简单一点就是将内存模型的对象变成字节数字，可以进行存储和传输;
反序列化：从IO流中恢复对象，将存储在磁盘或者从网络接收的数据恢复成对象模型;
使用场景：所有可在网络上传输的对象都必须是可序列化的，否则会出错；所有需要保存到磁盘的Java对象都必须是可序列化的。
序列化版本号:我们知道，反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼容性呢？​ Java序列化提供了一个``private static final long serialVersionUID` 的序列化版本号，只要版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级、代码的修改等因素无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。
所有需要网络传输的对象都需要实现序列化接口。
对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。如果想让某个变量不被序列化，使用transient修饰。序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。反序列化时必须有序列化对象的class文件。同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。
```java
/**
     * user对象通过字节流实现深拷贝
     * @throws CloneNotSupportedException
     */
    @Test
    public void deepClone() throws IOException, ClassNotFoundException {
        User user = new User("aa", "bb");
        user.setDog(new Dog("dog"));


        // 写出缓存字节数组
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(byteArrayOutputStream);
        out.writeObject(user);

        byte[] bytes = byteArrayOutputStream.toByteArray();

        // 将缓存字节数组写入程序对象
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
        ObjectInputStream in = new ObjectInputStream(byteArrayInputStream);

        User user1 = (User) in.readObject();

// 关闭资源
        byteArrayInputStream.close();
        in.close();
        out.close();
        byteArrayOutputStream.close();




        user.setName("xiugai");
        user.getDog().setName("xigou");


        System.out.println(user);
        System.out.println(user1);
    }

    @Test
    public void qianClone() throws CloneNotSupportedException {
        User user = new User("aa", "bb");
        user.setDog(new Dog("dog"));


        User user1 = (User) user.clone();

        user.setName("xiugai");
        user.getDog().setName("xigou");


        System.out.println(user);
        System.out.println(user1);
    }
```
