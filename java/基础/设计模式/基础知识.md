# 设计模式
# 六大原则
【单一原则】（Single Responsibility Principle）：一个类或者一个方法只负责一项职责。
【里氏替换原则】（LSP liskov substitution principle）：子类可以扩展父类的功能，但不能改变原有父类的功能。
【依赖倒置原则】（dependence inversion principle）：面向接口编程，（通过接口作为参数实现应用场景）。
（1）抽象就是接口或者抽象类，细节就是实现类；（2）上层模块不应该依赖下层模块，两者应依赖其抽象；（3）抽象不应该依赖细节，细节应该依赖抽象。
注：通俗点就是说变量或者传参数，尽量使用抽象类，或者接口。
【接口隔离原则】（interface segregation principle）：建立单一接口；（扩展为类也是一种接口，一切皆接口）
定义：a.客户端不应该依赖它不需要的接口；b.类之间依赖关系应该建立在最小的接口上；简单理解：复杂的接口，根据业务拆分成多个简单接口；（对于有些业务的拆分多看看适配器的应用）注：接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低；。
【迪米特原则】（law of demeter LOD）：最少知道原则，尽量降低类与类之间的耦合，一个对象应该对其他对象有最少的了解。
【开闭原则】（open closed principle）：对扩展开放，对修改闭合
# 设计模式的分类
单例模式：单实例即在系统全局，一个类只创建一个对象，并且在系统全局都可以访问这个对象而不用重新创建。
有效的控制对象的数量，毕竟，有的类其内部实现复杂，如果频繁创建销毁对象，可能还是很耗费服务器资源的。
分析SingleObject类的特征：
SingleObject类的`构造方法是私有的`，这样可以保证只能在SingleObject类内部才能创建对象，而无法在类外部创建SingleObject对象。
SingleObject类中有`一个instance成员属性`，单例类自己持有这个单例对象;
SingleObject类提供了一个`静态方法getInstance`，提供一个静态方法可在全局获取到这个单例对象;
`饿汉式`: 一加载类就急于创建对象的写法; 类加载classloader是单线程的，不存在并发问题；
`懒汉式(分线程不安全和安全)`:需要时再创建的写法，我们称之为懒汉式;特点：
- 创建对象的时机,调用getInstance内部;
- 多个线程并发调用时，getInstance可能创建多个实例；
改进线程安全：使用了synchronized加锁getInstance来保障并发,只会创建一个实例，不过synchronized的粒度较大，如果每次请求都经过getInstance方法，性能影响较大。
` 双检锁/双重校验锁`: synchronized加锁对性能有较大影响，双检锁的方式，是把锁的粒度尽可能降低，减少加锁对性能的影响;
分析双检锁的写法：
在成员属性instance上，我们增加了volatile关键字，保障多线程对instance值的可见性以及禁止指令重排。
通过双重检查的方式，在内部再进行synchronized加锁，可以降低锁的粒度，有效避免每次调用getInstance都加锁，因为getInstance在创建对象之后，instance一直都是非null的。双检锁这个方式，既可以保障不浪费资源，又可以保障在多线程的环境下保持高性能。
`静态内部类`的特点：
- 将instance放在了内部类SingletonHolder中, 饿汉式是类加载时就会立即创建对象，而`静态内部类不会`，它只会在调用了getInstance时，才会加载内部类SingletonHolder创建对象。

`枚举`：这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。


简单工厂模式：一个工厂类根据传入的参量决定创建出那一种产品类的实例。
 - 对象的创建过程比较复杂
 - 屏蔽掉对象的复杂的创建过程
工厂方法模式：实现抽象产品和抽象工厂，让具体工厂去实例化类；
- Product：抽象产品
- ConcreteProduct：具体产品
- Factory：抽象工厂
- ConcreteFactory：具体工厂
- 工厂方法模式虽然扩展性好，但是增加了编码难度，大量增加了类的数量；


抽象工厂模式：创建相关或依赖对象的家族，而无需明确指定具体类。
- AbstractFactory：抽象工厂
- ConcreteFactory：具体工厂
- AbstractProduct：抽象产品
- Product：具体产品
产品线概念

创建者模式：封装一个复杂对象的构建过程，并可以按步骤构造。
复杂对象的内部创建方法进行调用，组织协调了对象的各个部分前后顺序的控制。

代理模式：为其他对象提供一个代理以便控制这个对象的访问。
静态代理
抽象角色 : 一般使用接口或者抽象类来实现;
真实角色 : 被代理的角色(实现抽象角色);
代理角色 : 代理真实角色(实现抽象角色);
客户 : 使用代理角色来进行一些操作;
动态代理
动态代理的代理类是动态生成的 ，静态代理的代理类是我们写的；
动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理；
基于接口的动态代理-----JDK动态代理(实现相同的方法)
基于类的动态代理-----cglib

Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；
CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效。
CGLIB原理:CGLib底层采用ASM字节码生成框架,用字节码技术生成代理类，比使用Java反射效率要高。CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。广泛的被许多AOP的框架使用;
通过MethodInterceptor和Enhancer实现一个动态代理;
JDK中的动态代理是通过反射类Proxy以及InvocationHandler回调接口实现的,JDK中所要进行动态代理的类必须要实现一个接口，也就是说只能对该类所实现接口中定义的方法进行代理，这在实际编程中具有一定的局限性，而且使用反射的效率也并不是很高;
回调过滤器CallbackFilter：
在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。
在JDK动态代理中并没有类似的功能，对InvocationHandler接口方法的调用对代理类内的所以方法都有效。

原型模式：通过复制现有的实例来创建新的实例。
适配器模式：将一个类的方法接口转换成客户希望的另外一个接口
组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。
装饰模式：动态的给对象添加新的功能。

亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。
外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。
桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。将抽象与实现解耦。
模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。
解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。java.util.Pattern，java.text.Format
策略模式：定义一系列算法，把它们封装起来，并且使它们可以相互替换。
状态模式：允许一个对象在其对象内部状态改变时改变它的行为。
观察者模式：对象间的一对多的依赖关系。
备忘录模式：在不破坏封装的前提下，保持对象的内部状态。
中介者模式：用一个中介对象来封装一系列的对象交互。
命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。
责任链模式：将请求的发送者和接收者解耦，使得多个对象都有处理这个请求的机会。
迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。

聚合关系：是整体与部分的关系，且部分可以离开整体而单独存在。
组合关系：是整体与部分的关系，但部分不能离开整体而单独存在。
关联关系：是一种拥有的关系，它使一个类知道另一个类的属性和方法；
实现关系：是一种类与接口的关系，表示类是接口所有特征和行为的实现；
泛化关系：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为；