# Java泛型 Generics
1.引入泛型
看表面的意思，泛型就是指广泛的、普通的类型。泛型能够帮助我们把【类型明确】的工作推迟到创建对象或调用方法的时候。
意思就是：我定义类的时候不用管到底是什么类型，new这个对象或者调用这个对象的方法时才确定具体的类型。
2. 泛型类
泛型类也就是把泛型定义在类上，这样用户在使用类的时候才把类型给确定下来。
具体的方法就是使用<>加一个未知数，通常用 T K V 等大写字符表示，事实上只要是个单词就可以。
```java
// 泛型类
public interface Comparator<T>{
    int compare(T o1, T o2);
}
// jdk1.7以前
    SuperArray<String> superArray = new SuperArray<String>();
    // jdk1.7以后提出了钻石语法，可以进行类型的自动推断，后边的尖括号就不用写了
    SuperArray<String> superArray = new SuperArray<>();
    superArray.add("abc");
    String item = superArray.get(0);
```
3. 泛型方法
```java
public class Test2 {
    public <T> T show(T t) {
        System.out.println(t);
        return t;
    }

    public static <T> T show2(T one) { //这是正确的
        return null;
    }

    public static void main(String[] args) {
        Test2 test2 = new Test2();
        String show = test2.show("123");
        Integer show1 = test2.show(123);
    }
}
```
泛型必须得先定义才能够使用
定义泛型方法时，必须在返回值前边加一个<T>，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。

明确类型和不明确类型
# 范型通配符
## 无界
"?"可以接收任何类型<?>
可以不加但报警告
Raw use of parameterized class ‘xxxx‘ 警告
没有类型参数的泛型
```java
public static void printSuperArray(SuperArray<?> superArray){
    for (int i = 0;i<superArray.size();i++){
        System.out.println(superArray.get(i));
    }
}
```
使用原始类型（没有类型参数的泛型）是合法的，使用原始类型（没有类型参数的泛型）是合法的；存在大量不使用泛型的代码向下兼容；
## 上界
使用(SuperArray<? extends Dog> superArray)的形式来约定传入参数的上界，意思就是`泛型只能是Dog的或者Dog的子类`。

## 下界
使用(SuperArray<? super Dog> superArray)的形式来约定传入参数的下界，意思就是泛型只能是`Dog的或者Dog的超类`。

## 类型擦除
Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为类型擦除。

1. 泛型不能是基本数据类型
因为当类型擦除后，SuperArray的原始类型变为Object，但是Object类型不能存储double值，只能引用Double的值。

重载方法，因为泛型被擦除后，其实这两个方法参数都是一致的Object，并不能构成泛型。
```java
public static void print(Comparator<Object> comparator){
}
public static void print(Comparator<User> comparator){
}
```
虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。

重写setValue和getValue方法的子类，会生成有4个方法，子类中两个setValue方法，一个是参数Object类型，一个是Date类型，编译器自己生成的【桥方法】，我们从字节码中看到两个标志【ACC_BRIDGE, ACC_SYNTHETIC】；
public void setValue(java.util.Date);
descriptor: (Ljava/util/Date;)V
flags: ACC_PUBLIC

// 桥接方法，一会分析
public void setValue(java.lang.Object);
descriptor: (Ljava/lang/Object;)V
flags: ACC_PUBLIC, `ACC_BRIDGE, ACC_SYNTHETIC`

子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法,
而桥方法的内部实现，就只是去调用我们自己重写的那两个方法,
自己定义的setvalue和getValue方法上面的@Override只不过是假象;
编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟机去区别;

# 静态方法和静态类中的问题
泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数；泛型参数的`实例化`是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。

# 枚举 enum
```java
public enum SeasonEnum {
    SPRING,SUMMER,AUTUMN,WINTER;
}
```

## 枚举单利设计模式
```java

public class Singleton {
    public static final Singleton getInstance(){
        return SingletonHolder.INSTANT.singleton;
    }

    private enum SingletonHolder {
        INSTANT;

        private final Singleton singleton;

        SingletonHolder() {
            this.singleton = new Singleton();
        }
    }

    public static void main(String[] args) {
        System.out.println(Singleton.getInstance() == Singleton.getInstance());
    }
}
```
所有的枚举类型字段必须要有注释，说明每个数据项的用途;
枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有.
枚举比较推荐使用 ==
枚举类，它“天然”就是一个常量类，不存在被修改的风险;

