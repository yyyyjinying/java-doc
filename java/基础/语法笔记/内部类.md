# 内部类
一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类(inner class)
## 类的五大成员
- 属性、方法、构造器、代码块、内部类
## 内部类优点如下：
- 内部类可以直接访问外部类的成员，包括私有成员。
- 外部类要访问内部类的成员，必须要建立内部类的对象
- 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名 和$符号 。(比如，Person$Heart.class)
```java
// 创建外部类对象
Person p = new Person(); 
// 创建内部类对象
Heart heart = p.new Heart();
```
1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整；
2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏；
3.方便编写事件驱动程序；
4.方便编写线程代码。

# 成员内部类
- 不能书写静态变量和方法

```java
package com.example.netty.threed.lambdatuidao;

interface Dao {
    void show();
    void play();
}

public class Case02 {

    String name = "外部类属性";
    public static String type ="外部类静态属性";
    private int item = 1;

    public static void show() {
        System.out.println("外部类中的静态show方法");
    }

    public void print() {
        System.out.println("调用外部类中的打印方法");
    }

    public class Inner {
        String name = "内部类属性";

        public void innerShow(){

            System.out.println(item);
            System.out.println(name);

            print();

            show();

            System.out.println(Case02.this.name);

            System.out.println(Case02.type);

        }
    }


    public void demo() {
        String name = "局部变量name";
        String type = "局部变量type";

        show();
        print();

        class Inner {
            String name = "局部类的属性";

            public void showInner(String name){

                show();
                print();

                System.out.println(name);

            }
        }

        Inner inner = new Inner();
//        inner.showInner(name);
        inner.showInner(this.name);


    }


    //编写回调方法 ：callInner
    public void callInner(Dao dao){
        // 接口关系下的匿名内部类
        dao.show();
        dao.play();
    }

    public static class InnerCase{
        //四种权限修饰符可以修饰静态内部类
        public String name = "静态内部类的类名";
        static double weight = 1.8;
        String type = "静态内部类的type属性";
        public void show(){
            System.out.println("我是：" + weight);
            System.out.println("我是：" + type);
            System.out.println("我是：" + name);
            //System.out.println("我是：" + Static.type);//静态内部类中不能访问外部类非静态成员
            System.out.println("我是：" + Case02.type);
        }
    }


    public static void main(String[] args) {

        Case02 case02 = new Case02();
        Inner inner = case02.new Inner();



        inner.innerShow();

        System.out.println("----------");
        case02.demo();

        case02.callInner(new Dao(){
            //实现子类 但是没有名字 所以叫匿名内部类
            @Override
            public void show() {
                System.out.println("接口方法...");
            }

            @Override
            public void play() {
                System.out.println("play…………");
            }
        });

        InnerCase innerCase = new InnerCase();
        innerCase.show();

    }
}


```
1
内部类属性
调用外部类中的打印方法
外部类中的静态show方法
外部类属性
外部类静态属性

# 局部内部类
局部内部类的特点
1. 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；
2. 不可使用权限修饰符 静态(static)修饰符进行修饰 同局部变量相同；
3. 可以直接访问方法中的属性、外部类中属性和方法；
4. 创建对象, 要在方法内部;

# 匿名内部类
匿名内部类特点
匿名内部类不能定义任何静态成员、方法和类;
只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面;
形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递
```java
/* 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象
*/
FlyAble f = new FlyAble(){
   public void fly() { System.out.println("我飞了~~~");} 
};
/*创建匿名内部类,直接传递给showFly(FlyAble f) */
showFly(new FlyAble(){
public void fly() { System.out.println("我飞了~~~");
}});
```


# 静态内部类
静态内部类特点
1. 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static;
2. 静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法;
3. `静态内部类中即能声明静态成员也可以声明非静态成员`

# 代码块
​代码块又称初始化块，属于类中的成员，它是讲逻辑语句封装在方法体中，通过{} 包裹。代码块没有方法名，没有参数，没有返回值，只有方法体，而且不通过对象或类进行显示的调用，他会在类加载，或者创建对象时主动的隐式调用。
1.静态代码块：一个类被加载时会被调用一次，常用在需要做一些全局初始化的工作
2.实例代码块：每次创建实例，都会被调用 一次；
```java
public class User {
    // 静态代码块
    static {
        System.out.println("I am a static code  block!");
    }
    // 实例代码块
    {
        System.out.println("I am a instance code block!");
    }
    public static void main(String[] args) {
        new User();
        new User();
    }
}

结果：
I am a static code  block!
I am a instance code block!
I am a instance code block!
```
优先级：
父-》子
静态代码块-》实例代码块-》构造器
结果：记住
这是父类的静态代码块！
这是子类的静态代码块！
这是父类的实例代码块！
这是父类的构造器！
这是子类的实例代码块！
这是子类的构造器！