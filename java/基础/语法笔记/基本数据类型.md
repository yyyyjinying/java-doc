基本数据类型有8种，
分别是：
byte（位）、
short（短整数）、
int（整数）、
long（长整数）、
float（单精度）、
double（双精度）、
char（字符）、
boolean（布尔值）

数据类型转换：
自动类型转换；
强制类型转换；

数组的定义：
```java
int[] arrs = new int[4];
int[] arrs = new int[]{1,2,3};
int[] arrs = {1,2,3};
```
# 类与对象的关系
类是对一类事物的描述，是抽象的。 
对象是一类事物的实例，是具体的。 
类是对象的模板，对象是类的实体。

# 类
- 成员变量
成员变量的默认值
基本类型8种：
整数(byte，short，int，long)
浮点数(float，double)
字符(char)
布尔(boolean)
引用类型：
数组，类，接口


- 成员方法


# 成员变量和局部变量
- 在类中的位置不同 
成员变量:类中，方法外
局部变量:方法中或者方法声明上(形式参数)
- 在内存中的位置不同
成员变量:堆内存 
局部变量:栈内存

# 生命周期不同
成员变量:随着对象的创建而存在，随着对象的消失而消失
局部变量:随着方法的调用而存在，随着方法的调用完毕而消失

# 权限修饰符
被private修饰后的成员变量和成员方法，只在本类中才能访问。

# this的含义
this代表所在类的当前对象的引用(地址值)，即对象自己的引用。

# 构造方法的定义格式
- 方法名与所在的类名相同
- 需要返回值类型
- 修饰符 方法名(){}
- 如果你不提供构造方法，系统会给出无参数构造方法。
- 如果你提供了构造方法，系统将不再提供无参数构造方法。
- 构造方法是可以重载的，既可以定义参数，也可以不定义参数。

# javaBean
- 成员变量
- 成员方法
- 无参构造方法
- 有参构造方法 

# 基本类型和基本类型包装类
基本类型 基本类型包装类
byte | Byte
short | Short
int | Integer
long | Long
float | Float
double | Double
char | Character
boolean | Boolean

# String字符串
- 字符串不变:字符串的值在创建后不能被更改；
```java
String s1 = "abc";
s1 += "d";
System.out.println(s1); // "abcd"
// 内存中有"abc"，"abcd"两个对象，s1从指向"abc"，改变指向，指向了"abcd"。

String s1 = "abc";
String s2 = "abc";
// 内存中只有一个"abc"对象被创建，同时被s1和s2共享。

字符串的构造
 // 无参构造
String str = new String();
// 通过字符数组构造
char chars[] = {'a', 'b', 'c'}; String str2 = new String(chars);
// 通过字节数组构造
byte bytes[] = { 97, 98, 99 }; String str3 = new String(bytes);

// equalsIgnoreCase 忽略大小写
 public boolean equals (Object anObject) :将此字符串与指定对象进行比较

```
# concat 与 +
新字符串仅当输出字符串的长度大于零时，concat方法才会在追加后创建新的字符串对象作为输出，`+`始终创建新的字符串；
# String与char的关系
```java
"abc" 等效于 char[] data={ 'a' , 'b' , 'c' }
 例如:
String str = "abc";
相当于:
char data[] = {'a', 'b', 'c'}; String str = new String(data); // String底层是靠字符数组实现的。
```


# static 
它属于类，就可以不靠创建对象来调用了。
`类变量`的使用： 可以作为多个对象的共享变量；
当 static 修饰成员方法时，该方法称为`类方法`

## 静态方法调用的注意事项:
静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。 静态方法中，不能使用this关键字。


是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域(静态区)，所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。

#  静态代码块
静态代码块:定义在成员位置，使用static修饰的代码块{ }。
位置:类中方法外。 执行:随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。

# 
```java
// 给类变量进行初始化赋值
public class Game {
    public static int number;
    public static ArrayList<String> list;
    static {
    // 给类变量赋值
    number = 2;
    list = new ArrayList<String>(); // 添加元素到集合中     list.add("张三"); list.add("李四");
    } 
}
```

# super和this的含义
- super :代表父类的存储空间标识(可以理解为父亲的引用)。 
- this :代表当前对象的引用(谁调用就代表谁)。
- 在构造方法中不能同时出现： super() 和 this() 都必须是在构造方法的第一行

# 抽象类
父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有 意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。Java语法规定，包含抽象方法 的类就是抽象类。
定义
- 抽象方法 : 没有方法体的方法。 
- 抽象类: 包含抽象方法的类。
- 实现方法：子类重写父类的抽象方法；
- 抽象类不能创建对象；

# 接口
- 接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。

## 优先级的问题
当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。
- 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。 
- 接口中，没有构造方法，不能创建对象。
- 接口中，没有静态代码块。





