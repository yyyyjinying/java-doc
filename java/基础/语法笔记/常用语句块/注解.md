# 相关注解

```java
@Bean
@ConditionalOnMissingBean({HiddenHttpMethodFilter.class})
@ConditionalOnProperty(
    prefix = "spring.mvc.hiddenmethod.filter",
    name = {"enabled"}
)
 public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
    return new OrderedHiddenHttpMethodFilter();
}

@Bean
@ConditionalOnMissingBean(AMapper.class)
public AMapper aMapper1(AConfig aConfig) {
return new AMapperImpl1(aConfig);
}

@Bean
public AMapper aMapper2(AConfig aConfig) {
return new AMapperImpl2(aConfig);
}

@ConditionalOnMissingBean 
它是修饰bean的一个注解，当你的bean被注册之后，如果有注册相同类型的bean，就不会成功，它会保证你的bean只有一个，即你的实例只有一个，当你注册多个相同的bean时，会出现异常，以此来告诉人员。

@ConditionalOnProperty
控制配置类是否生效，实现是通过havingValue与配置文件中的值对比,返回为true则配置类生效,反之失效.
```
```java
// matchIfMissing：默认选择的配置项为空时，matchIfMissing为true
@ConditionalOnProperty(name = "shiro.web.enabled", matchIfMissing = true)

// @ConditionalOnProperty
// 实现是通过havingValue与配置文件中的值对比,返回为true则配置类生效,反之失效.
@Bean(name = "smsNotification")
@ConditionalOnProperty(prefix = "notification", name = "service", havingValue = "sms")
public NotificationSender notificationSender2() {
    return new SmsNotification();
}
// 配置Spring Boot通过@ConditionalOnProperty来控制Configuration是否生效
@Bean
@ConditionalOnProperty(name = "xxx1", havingValue = "false", matchIfMissing = true)
public SecureProxyService secureProxyService() {
    return new SecureProxyServiceImpl();
}

@Bean
@ConditionalOnProperty(name = "xxx1", havingValue = "true")
public SecureProxyService SecureProxyServiceImpl1() {
    return new SecureProxyServiceImpl1();
}
```

# @Conditional 条件判断相关的注解
@ConditionalOnBean：当容器里有指定Bean的条件下
@ConditionalOnClass：当类路径下有指定类的条件下
@ConditionalOnExpression：基于SpEL表达式作为判断条件
@ConditionalOnJava：基于JV版本作为判断条件
@ConditionalOnJndi：在JNDI存在的条件下差在指定的位置
@ConditionalOnMissingBean：当容器里没有指定Bean的情况下
@ConditionalOnMissingClass：当类路径下没有指定类的条件下
@ConditionalOnProperty：指定的属性是否有指定的值
@ConditionalOnResource：类路径是否有指定的值
@ConditionalOnSingleCandidate：当指定Bean在容器中只有一个，或者虽然有多个但是指定首选Bean
@ConditionalOnWebApplication：当前项目是Web项目的条件下
@ConditionalOnNotWebApplication：当前项目不是Web项目的条件下


# 如何控制配置类的加载顺序
```java
// 要求ClassA先加载，然后在加载ClassB
@Configuration
public class ClassA {

}

@Configuration
@AutoConfigureAfter(ClassA.class)
@Import(ClassA.class)
public class ClassB {
}
```

```java

public class Car {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

@Configuration
public class Config {
    public Config() {
        System.out.println("TestConfig容器初始化...");
    }

    @Bean(name = "getMyCar")
    public Car getCar() {
        Car c = new Car();
        c.setName("dankun");
        return c;
    }
}

@Component
public class Car {
    @Value("dankun")
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}

@Configuration
@ComponentScan("com.wuyue.annotation")
public class Config {
public Config() {
    System.out.println("TestConfig容器初始化...");
}


```

# spring boot的原理
1