# 相关注解

```java
@Bean
@ConditionalOnMissingBean({HiddenHttpMethodFilter.class})
@ConditionalOnProperty(
    prefix = "spring.mvc.hiddenmethod.filter",
    name = {"enabled"}
)
 public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
    return new OrderedHiddenHttpMethodFilter();
}

@Bean
@ConditionalOnMissingBean(AMapper.class)
public AMapper aMapper1(AConfig aConfig) {
return new AMapperImpl1(aConfig);
}

@Bean
public AMapper aMapper2(AConfig aConfig) {
return new AMapperImpl2(aConfig);
}

@ConditionalOnMissingBean 
它是修饰bean的一个注解，当你的bean被注册之后，如果有注册相同类型的bean，就不会成功，它会保证你的bean只有一个，即你的实例只有一个，当你注册多个相同的bean时，会出现异常，以此来告诉人员。

@ConditionalOnProperty
控制配置类是否生效，实现是通过havingValue与配置文件中的值对比,返回为true则配置类生效,反之失效.
```
```java
// matchIfMissing：默认选择的配置项为空时，matchIfMissing为true
@ConditionalOnProperty(name = "shiro.web.enabled", matchIfMissing = true)

// @ConditionalOnProperty
// 实现是通过havingValue与配置文件中的值对比,返回为true则配置类生效,反之失效.
@Bean(name = "smsNotification")
@ConditionalOnProperty(prefix = "notification", name = "service", havingValue = "sms")
public NotificationSender notificationSender2() {
    return new SmsNotification();
}
// 配置Spring Boot通过@ConditionalOnProperty来控制Configuration是否生效
@Bean
@ConditionalOnProperty(name = "xxx1", havingValue = "false", matchIfMissing = true)
public SecureProxyService secureProxyService() {
    return new SecureProxyServiceImpl();
}

@Bean
@ConditionalOnProperty(name = "xxx1", havingValue = "true")
public SecureProxyService SecureProxyServiceImpl1() {
    return new SecureProxyServiceImpl1();
}
```

# @Conditional 条件判断相关的注解
@ConditionalOnBean：当容器里有指定Bean的条件下
@ConditionalOnClass：当类路径下有指定类的条件下
@ConditionalOnExpression：基于SpEL表达式作为判断条件
@ConditionalOnJava：基于JV版本作为判断条件
@ConditionalOnJndi：在JNDI存在的条件下差在指定的位置
@ConditionalOnMissingBean：当容器里没有指定Bean的情况下
@ConditionalOnMissingClass：当类路径下没有指定类的条件下
@ConditionalOnProperty：指定的属性是否有指定的值
@ConditionalOnResource：类路径是否有指定的值
@ConditionalOnSingleCandidate：当指定Bean在容器中只有一个，或者虽然有多个但是指定首选Bean
@ConditionalOnWebApplication：当前项目是Web项目的条件下
@ConditionalOnNotWebApplication：当前项目不是Web项目的条件下


# 如何控制配置类的加载顺序
```java
// 要求ClassA先加载，然后在加载ClassB
@Configuration
public class ClassA {

}

@Configuration
@AutoConfigureAfter(ClassA.class)
@Import(ClassA.class)
public class ClassB {
}
```

```java

public class Car {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

@Configuration
public class Config {
    public Config() {
        System.out.println("TestConfig容器初始化...");
    }

    @Bean(name = "getMyCar")
    public Car getCar() {
        Car c = new Car();
        c.setName("dankun");
        return c;
    }
}

@Component
public class Car {
    @Value("dankun")
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}

@Configuration
@ComponentScan("com.wuyue.annotation")
public class Config {
public Config() {
    System.out.println("TestConfig容器初始化...");
}


```

# spring boot的原理
# 自动装配的大致流程
当启动SpringBoot应用程序的时候，会先创建SpringApplication对象，在构造方法中会进行一些参数的初始化工作，比如会加载Spring.factories文件，将文件的内容放到缓存对象中，方便后续获取

SpringApplication对象创建完成后，开始调用run方法，启动过程中最主要有两个方法，第一个叫prepareContext()，第二个叫refreshContext()方法

在prepareContext()方法主要是对上下文对象ConfigurableApplicationContext的初始化操作，在整个过程中有个非常重要的方法就是load()方法，它会将当前启动类作为一个BeanDefinition注册到BeanDefinitionMap中，方便后续在进行BeanFactoryPostProcessor调用执行的时候，找到对应的启动类，来完成对应注解的解析工作

在refreshContext()方法会进行整个Spring容器的刷新refresh操作，会调用spring的refresh()方法，自动装配过程是在invokeBeanFactoryPostProcessor方法()中进行（也就是执行BeanFactory的后置处理器），在此方法主要是针对ConfigurationClassPostProcessor类的处理

在执行BeanFactory后置处理器的时候会调用ConfigurationClassPostProcessor类中的parse()方法去解析处理各种注解比如@CompomentScan、@Import等等

在解析@Import注解的时候比较特别，会有一个collectImports()方法，从主类开始递归解析注解，把所有包含@Import的注解都解析到BeanDefinitionMap中

调用AutoConfigurationImportSelector类（相当于一个处理器）中的process()方法进而触发getCandidateConfigurations()方法获取Spring.factories文件下的key为EnableAutoConfiguration的所有value，所以这就是为什么很多人的文章中都说Springboot的自动装配就是调用@EnableAutoConfiguration注解下的@Import中的AutoConfigurationImportSelector类，主要就是通过这种不断解析注解的方法去调用的