# 核心概念
# 进程
一个正在执行中的程序就是一个进程，系统会为这个进程发配独立的【内存资源】。进程是程序的一次执行过程，它有自己独立的生命周期，它会在启动程序时产生，运行程序时存在，关闭程序时消亡。
# 线程
线程是由进程创建的，是进程的一个实体，是具体干活的人，一个进程可能有多个线程。线程不独立分配内存，而是共享进程的内存资源，线程可以共享cpu的计算资源。进程更强调【内存资源的分配】，而线程更强调【计算资源的分配】。因为有了线程的概念，一个进程的线程就不能修改另一个线程的数据，隔离性更好，安全性更好。

同一时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错觉；
多线程是多个cpu及多核，例如服务器；
在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统
紧密相关的，先后顺序是不能认为的干预的；
对于同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；
线程会带来额外的开销，如cpu调度时间，并发控制开销
每个线程在自己的工作内存中交互，加载和存储只内存控制不当会造成数据不一致；

java中多用实现，少用继承，单继承的局限性；
写多线程的两种方法：
1、继承thread类，重写run方法，调用子类对象的start()方法；
2、实现Runable，重写run方法， 借助thread类（有操作cpu的方法）的对象调用start方法，new thread(p).start();
tread是代理对象，p是真实对象
# 上下文切换
用户线程执行的过程我们称之为【用户态】，内核调度的状态称之为【内核态】，每一个线程运行时产生的数据我们称之为【上下文】，`线程的每次切换`都需要进行用户态到内核态的来回切换，同时伴随着上下文的切换，是一个比较消耗资源的操作，所以一个计算机当中不是线程越多越好，线程如果太多也是有可能拖垮整个系统的。
# 两种创建多线程的方法，继承Thread 和实现Runnable
Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。 而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法
实现Runnable接口比继承Thread类所具有的优势:
1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。
3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。
扩充:在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用 java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。
# 守护线程
Java提供两种类型的线程：用户线程和守护程序线程。守护线程旨在为用户线程提供服务，并且仅在用户线程运行时才需要。
守护线程:守护线程对于后台支持任务非常有用，例如垃圾收集，释放未使用对象的内存以及从缓存中删除不需要的条目。大多数JVM线程都是守护线程。在比如qq等等聊天软件,主程序是非守护线程,而所有的聊天窗口是守护线程,当在聊天的过程中,直接关闭聊天应用程序时,聊天窗口也会随之关。包括word中我们在书写文字的时候，还有线程帮我们进行拼写检查，这都是守护线程。
```java
NewThread daemonThread = new NewThread();
daemonThread.setDaemon(true);
daemonThread.start();
```
# 线程生命周期
NEW: Thread.start()调用前的状态;
RUNNABLE: 就绪状态；等待来自操作系统调度；
BLOCKED： 阻塞，挂起；
WAITING：无限期等待；Object.wait(0)，Thread.join(0)和LockSupport.park；未设置超时时间；
TIMED_WAITING： 有限期等待；
TERMINATED： 终止状态 terminated

# CPU多核缓存架构
CPU缓存为了提高程序运行的性能，现代CPU在很多方面会对程序进行优化。CPU的处理速度是很快的，内存的速度次之，硬盘速度最慢。在CPU处理内存数据中，内存运行速度太慢，就会拖累CPU的速度。为了解决这样的问题，CPU设计了多级缓存策略。
CPU分为三级缓存： 每个CPU都有L1,L2缓存，但是L3缓存是多核公用的。
CPU查找数据的顺序为： CPU -> L1 -> L2 -> L3 -> 内存 -> 硬盘
进一步优化，CPU每次读取一个数据，并不是仅仅读取这个数据本身，而是会读取与它相邻的64个字节的数据，称之为【缓存行】，因为CPU认为，我使用了这个变量，很快就会使用与它相邻的数据，这是计算机的局部性原理。这样，就不需要每次都从主存中读取数据了。

这种多级缓存的结构下，会有什么问题呢？最经典的就是【`可见性的问题`】，可以简单的理解为，一个线程修改的值对其他线程可能不可见。
​ 比如两个CPU读取了一个缓存行，缓存行里有两个变量，一个x一个y。第一颗CPU修改了x的数据，还没有刷回主存，此时第二颗CPU，从主存中读取了未修改的缓存行，而此时第一颗CPU修改的数据刷回主存，这时就出现，第二颗CPU读取的数据和主存不一致的情况。
​ 为了解决数据不一致的问题，很多厂商提出了自己的解决方案，比如英特尔的MESI协议。
MESI协议规定每条缓存都有一个状态位，同时定义了一下四种状态：
修改态 (Modified) 此缓存被修改过，内容与住内存不同，为此缓存专有
专有态 (Exclusive) 此缓存与主内存一致，但是其他CPU中没有
共享态 (Shared) 此缓存与住内存一致，但也出现在其他缓存中。
无效态 (Invalid) 此缓存无效，需要从主内存中重新读取。
除了存在可见性的问题，当多个线程同时修改相同资源的时候，还会存在`资源的争夺问题`。
 除了增加高速缓存之外，为了使处理器内部的运算单元尽量被充分利用。处理器可能会对输入的代码进行【乱序执行】，优化处理器会在计算之后将乱序执行的结果【进行重组】，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句的先后执行顺序与输入代码中的顺序一致。因此如果存在一个计算任务，依赖于另外一个依赖任务的中间，结果那么顺序性不能靠代码的先后顺序来保证。 Java虚拟机的即时编译器中也有【指令重排】的优化。

​ 咱们可以举一个简单的例子来形象的说明一下，比如现在我们有这么一个需求，有四条指令，这四条指令分别是让四个人在四张纸上写下【新年快乐】四个字。但是在这个过程当中，有的人写的快，有的人写得慢，而如果我们非要按照新年快乐这四个顺序去执行这个工作的话，可能时间会浪费的多一点，那我们不妨让这四个人分别去写他们这四个字儿，我们等着这四个人最后一个写完了，然后再把这四个字组合在一起，我们就达到目的了，这样的乱序执行效率可能会更高一些。

#

