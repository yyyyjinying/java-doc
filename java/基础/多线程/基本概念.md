# 多任务
# 多线程
# 程序（静态概念） 进程（动态概念） -》 多线程（一个进程中开辟多条路径）-调度器并发控制
每个线程都有自己的工作内存，工作内存再跟主内存打交道；
主存和工作内存数据不一致（拷贝）

# java中创建多线程三种方式
## 继承Thread 类
## 实现Runable 接口
## 实现Callable接口（juc并发包下的）


少用继承多用实现
单继承的局限性 

父类和子类， 直接继承子类，是继承关系extends
### 
Thread用于创建执行可运行任务的线程;
创建Thread时生成线程唯一的标识符(不可需改)和一个名称（可修改）；

平台线程：
虚拟线程是守护线程，因此不会阻止Java虚拟机终止。虚拟线程具有固定的线程优先级，不能更改。
想关闭java虚拟机不需要等待守护线程的关闭；

Lesson02 lesson02 = new Lesson02(333);
// 正常顺序执行
new Thread(lesson02).run();
// 多线程执行
new Thread(lesson02).start();
start（）方法加入到调度其中，不一定立即执行，系统安排调度执行；
直接用run()方法不开启线程，只是普通方法执行；

# 内部类和外部类的区别

# 静态代理类和动态代理类

# lambal表达式推导
- 静态内部类-》局部内部类-〉匿名内部类-》lambad表达式

# 线程状态
- NEW 新建状态
- 就绪状态 yield
- 执行状态
- 阻塞状态 sleep join
- 死亡状态

1、新建状态（New）：新创建了一个线程对象。
2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

## 线程睡眠
Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
## 线程等待
Object中有wait,notify,notifyAll方法
wait(）方法，导致当前的线程阻塞等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法，行为等价于调用 wait(0) 一样。
## 线程让步
Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程
yield()方法称为“退让”，它把运行机会让给了同等优先级的其他线程
## 线程加入
join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
## 线程唤醒
Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。

# 调整线程优先级
JVM提供了10个线程优先级
Java线程有优先级，优先级高的线程会获得较多的运行机会。

# synchronized关键字
- synchronized关键字是不能继承的;
- synchronized关键字的作用域有二种：同步方法和同步语句块
synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。

A．无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。
B．每个对象只有一个锁（lock）与之相关联。
C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

### 总结一下：
1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。
2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法
3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。
4、对于同步，要时刻清醒在哪个对象上同步，这是关键。
5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。
6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。
7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉

# 死锁
死锁: 过多的同步可能造成相互不释放资源
从而相互等待，一般发生于同步中持有多个对象的锁
避免: 不要在同一个代码块中，同时持有多个对象的锁
# 线程不安全  ticketNums对象在变
```java
 public void test02() {
    // //线程不安全  ticketNums对象在变
    synchronized((Integer) ticketNums){
        if(ticketNums<=0) {//考虑的是没有票的情况
            flag = false;
            return ;
        }
        //模拟延时
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(Thread.currentThread().getName()+"-->"+ticketNums--);
    }
}
```

# Java内存模型的三大特性
可见性（当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改）
原子性（一个操作或一系列操作是不可分割的，要么同时成功，要么同时失败）
有序性（变量赋值操作的顺序与程序代码中的执行顺序一致）
关于有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

# 指令重排
计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。
可以回想下小学时候的数学题：2+3-5=?，如果把运算顺序改为3-5+2=?，结果也是一样的。
`指令重排是要保证单线程下程序结果不变的情况下做重排`

# 有哪几种重排
- 编译器优化重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统重排：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

源代码-〉编译器优化重排-〉指令级并行重排 -》内存系统重排 -〉最终执行的指令

指令重排必须考虑数据的依赖性；
编译器优化重排的存在，再多线程下，无法保证变量的一致；

# volatile都不保证原子性，为啥我们还要用它？
volatile是轻量级的同步机制，对性能的影响比synchronized小。
典型的用法：检查某个状态标记以判断是否退出循环。

## 那为什么我们不直接用synchorized，lock锁？它们既可以保证可见性，又可以保证原子性为何不用呢？
因为synchorized和lock是排他锁（悲观锁），如果有多个线程需要访问这个变量，
将会发生竞争，只有一个线程可以访问这个变量，其他线程被阻塞了，会影响程序的性能。

## volatile和synchronzied的区别
- volatile只能修饰实例变量和类变量，synchronized可以修饰方法和代码块。
- volatile不保证原子性，而synchronized保证原子性
- volatile 不会造成阻塞，而synchronized可能会造成阻塞
- volatile 轻量级锁，synchronized重量级锁
- volatile 和synchronized都保证了可见性和有序性

## volatile 保证了可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。
volatile 保证了单线程下指令不重排：通过插入内存屏障保证指令执行顺序。
volatitle不保证原子性，如a++这种自增操作是有并发风险的，比如扣减库存、发放优惠券的场景。
volatile 类型的64位的long型和double型变量，对该变量的读/写具有原子性。
volatile 可以用在双重检锁的单例模式种，比synchronized性能更好。
volatile 可以用在检查某个状态标记以判断是否退出循环。
# volatile的内存语义(保证可见性和有序性)
当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中;
当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量

        

# 弱引用 和 强引用

# 悲观锁和乐观锁

# ​ ThreadLocal
为线程本地变量，用于解决多线程并发时访问共享变量的问题。
- 多线程访问同一个变量会修改同一个变量，
- 使用ThreadLocal可以为每一个线程创建一个变量，线程的变量是不共享的。

```java
public class ThreadLocalTest03 {
    private static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(()-> 1);
    public static void main(String[] args) {
        new Thread(new MyRun()).start();
        new Thread(new MyRun()).start();
    }
    public static  class MyRun implements Runnable{
        public MyRun() {
            threadLocal.set(-100);
            System.out.println(Thread.currentThread().getName()+"-->"+threadLocal.get());
        }
        public void run() {
            System.out.println(Thread.currentThread().getName()+"-->"+threadLocal.get());
            //new Thread(new MyRunxxx()).start();
        }
    }
}

// 结果
main-->-100
Thread-0-->1
main-->-100
Thread-1-->1
```
### InheritableThreadLocal
继承上下文，拷贝一份给子线程
```java
public class ThreadLocalTest04 {
//    public static ThreadLocal threadLocal = new InheritableThreadLocal<>();
    public static ThreadLocal threadLocal = new ThreadLocal();
    public static void main(String[] args) {
        threadLocal.set(5);
        System.out.println(Thread.currentThread().getName() + "-->" + threadLocal.get());
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "-->" + threadLocal.get());
        }).start();
    }
}
```
# 线程池
(1) 降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
(2) 提高响应速度。 当任务到达时，任务可以不需要等到线程创建就能立即执行。
(3) 提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。
# jdk自带的四种线程池
Java通过Executors提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。
# CountDownLatch （倒计时器）
​ 这个类常常用于等待，等多个线程执行完毕，再让某个线程执行。
​ CountDownLatch的典型用法就是：某一线程在开始运行前等待n个线程执行完毕。
使用方法如下：
将 CountDownLatch 的计数器初始化为n ：new CountDownLatch(n)，
每当一个任务线程执行完毕，就将计数器减1 countdownlatch.countDown()，当计数器的值变为0时，
在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行

# CyclicBarrier 和 CountDownLatch 的区别
CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。
CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。
# AbstractQueuedSynchronizer AQS
抽象队列同步器，用来解决线程同步执行的问题
CountDownLatch,ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的;

# AQS 定义两种资源共享方式
Exclusive（独占）:
只有一个线程能执行，如 ReentrantLock。
又可分为公平锁(线程在队列中排队的顺序，先到先得，如果发现有线程处在等待状态，继续等待)和非公平锁（非公平锁在lock后，首先会调用CAS进行进行一次抢锁，没有占用，就取到锁返回，如果被占用CAS失败，继续排队，但发现被释放锁就再次CAS抢锁；）
 Share（共享）；

 # 并发编程的三大特性
 原子性：
 将整个操作视为一个整体是原子性的核心特征。原子性不仅仅是多行代码，也可能是多条指令。
 可见性：
 有序性：

 volatile：可以保证可见性和有序行；
 synchronized和Lock：可以保证原子性、可见性、有序性；

 # CAS
 compare and swap的缩写比较并交换
 三个动作：【取值】、【比较】、【赋值】，只不过这三个动作是CPU原语级别的原子动作；
给一个元素赋值的时候，先看看内存里的那个值到底变没变，如果没变我就修改，变了我就不改了；如果失败了，进行补偿，也就是你可以继续尝试。
Java中的CAS是通过sun.misc.Unsafe类提供的；
CAS保证的是对一个对象写操作的无锁原子性；
缺点：
ABA问题；
循环时间长开销大；
只能对一个变量进行原子操作；
# LockSupport
是一个线程阻塞工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，当然阻塞之后肯定得有唤醒的方法。
public static void park(); // 无期限暂停当前线程
public static void unpark(Thread thread); // 恢复当前线程
# Lock锁
```java
// 获取锁  
void lock()   

// 仅在调用时锁为空闲状态才获取该锁，可以响应中断  
boolean tryLock()   

// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁  
boolean tryLock(long time, TimeUnit unit)   

// 释放锁  
void unlock()  

Lock lock = ...;
lock.lock();
try{
    //处理任务
}catch(Exception ex){

}finally{
    lock.unlock();   //释放锁
}
Lock lock = ...;
if(lock.tryLock()) {
     try{
         //处理任务
     }catch(Exception ex){

     }finally{
         lock.unlock();   //释放锁
     } 
}else {
    //如果不能获取锁，则直接做其他事情
}
```
synchronized和ReentrantLock的区别：
Lock是一个接口，synchronized是Java中的关键字，synchronized是内置的语言实现；
synchronized发生异常时，会自动释放线程占用的锁，故不会发生死锁现象。Lock发生异常，若没有主动释放，极有可能造成死锁，故需要在finally中调用unLock方法释放锁；
Lock可以让等待锁的线程响应中断，使用synchronized只会让等待的线程一直等待下去，不能响应中断
Lock可以提高多个线程进行读操作的效率
# ReentrantReadWriteLock
读写锁给我们提供了一种锁，读的时候可以很多线程同时读，但是不能有线程写，写的时候是独占的，其他线程既不能写也不能读。在某些场景下能极大的提升效率。

# 线程池
自JDK5之后，Java推出了一个并发包，java.util.concurrent，在Java开发中，我们接触到了好多池的技术，String类的对象池、Integer的共享池、连接数据库的连接池、Struts1.3的对象池等等，池的最终目的都是节约资源，以更小的开销做更多的事情，从而提高性能。
# 为什么要使用线程池？
(1) 降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
(2) 提高响应速度。 当任务到达时，任务可以不需要等到线程创建就能立即执行。
(3) 提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。
# jdk自带的四种线程池
ava通过Executors提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。